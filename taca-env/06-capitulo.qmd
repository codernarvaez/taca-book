---
title: "Propiedades de Decisión para Lenguajes Regulares"
author: "Christian Leonardo Robles Maza"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
  html:
    toc: true
    number-sections: true
    code-fold: true
---

# Propiedades de Decisión para Lenguajes Regulares  
Este documento presenta una explicación **profunda**, **detallada** y **estructurada** sobre tres propiedades de decisión fundamentales para los **lenguajes regulares** y sus autómatas asociados:

1. **¿El lenguaje aceptado es vacío?**
2. **¿El lenguaje aceptado es finito o infinito?**
3. **Problema de pertenencia: ¿Una cadena \( w \) pertenece a \( L(A) \)?**

Cada sección incluye **intuición**, **fundamento formal**, **algoritmos**, **pseudocódigo**, **tablas**, **notas**, **consejos prácticos**, y **ejemplos completos**.

---

## 1. Notación Formal y Recordatorio Teórico

Antes de analizar propiedades de decisión, recordemos la estructura formal de un autómata determinista finito (DFA):

\[
A = (Q, \Sigma, \delta, q_0, F)
\]

| Símbolo | Descripción |
|---------|-------------|
| \( Q \) | Conjunto finito de estados |
| \( \Sigma \) | Alfabeto de entrada |
| \( \delta \) | Función de transición \( \delta: Q \times \Sigma \to Q \) |
| \( q_0 \) | Estado inicial |
| \( F \subseteq Q \) | Conjunto de estados finales |

> **Nota:**  
> Si trabajas con un NFA, estas propiedades siguen siendo decidibles. Solo cambia el método de recorrido (se usa conjuntos de estados).

---

# 2. ¿El Lenguaje Aceptado es Vacío?

## 2.1 Intuición

El lenguaje \( L(A) \) es **vacío** cuando **no existe ningún camino** desde el estado inicial \( q_0 \) hacia un estado final en \( F \).

Esto es un problema de **conectividad en grafos dirigidos**.

> **Idea clave:**  
> Si puedo llegar a un estado final, entonces existe al menos una palabra aceptada → el lenguaje NO es vacío.

---

## 2.2 Algoritmo General

1. Realizar una **búsqueda BFS o DFS** desde el estado inicial.
2. Marcar todos los estados visitados.
3. Si durante el recorrido se alcanza algún estado \( f \in F \), entonces:
   - **El lenguaje NO es vacío**.
4. Si el recorrido termina sin visitar estados finales:
   - **El lenguaje es vacío**.

---

## 2.3 Pseudocódigo

```pseudo
function esVacio(DFA A):
    stack ← [q0]
    visitado ← {q0}

    while stack not empty:
        q ← pop(stack)

        if q in F:
            return false   # Hay camino a un final → NO es vacío

        for cada símbolo a en Σ:
            q' ← δ(q, a)
            if q' not in visitado:
                visitado.add(q')
                push(stack, q')

    return true  # Nunca alcanzamos un estado final
```
## 2.4 Complejidad

El coste de la comprobación de vacuidad se corresponde con una exploración del grafo de estados del autómata. Sea \(Q\) el conjunto de estados y \(E\) el conjunto de transiciones (aristas). Entonces:

- Tiempo: \(O(|Q| + |E|)\) — coste de una BFS/DFS. Dado que generalmente \(|E|\approx |Q|\cdot|\Sigma|\), se puede expresar también como \(O(|Q|\cdot|\Sigma|)\).
- Espacio: \(O(|Q|)\) para la marca de visitados y la estructura de la cola/pila.

Consejo práctico: eliminar estados inalcanzables antes de ejecutar otros algoritmos reduce el tamaño efectivo del grafo y acelera todos los procedimientos posteriores.

## 2.5 Ejemplo Ilustrativo

Dado el autómata (representación simplificada):


q0 -> q1
q1 -> q2
q2 (no es final)

Ninguna transición llega a estados finales.

➡ Lenguaje vacío.
```

Consejo: Siempre elimina primero estados inalcanzables. Acelera todos los demás algoritmos.
```
---

# 3. ¿El Lenguaje Aceptado es Finito o Infinito?

## 3.1 Intuición Fundamental

Un lenguaje regular es infinito si y solo si existe:

1. Un ciclo alcanzable desde el estado inicial; y
2. Desde ese ciclo se puede llegar a un estado final.

Tabla rápida:

| Condición | Resultado |
|---|---:|
| Hay ciclo útil | Lenguaje infinito |
| No hay ciclo útil | Lenguaje finito |

Definición: ciclo útil → ciclo que conduce (directa o indirectamente) a un estado final.

## 3.2 Fundamento Formal

Si hay un ciclo accesible que llega a un final, entonces puede repetirse arbitrariamente y generar infinitas palabras. Formalmente, si existen palabras \(u,v,w\) con \(v\) no vacío tal que \(u v^k w \in L(A)\) para todo \(k\ge 0\), entonces \(L(A)\) es infinito.

Si no hay ciclos útiles, el autómata alcanzable desde \(q_0\) es esencialmente acíclico y solo admite palabras de longitud limitada.

## 3.3 Algoritmo usando Componentes Fuertemente Conexas (SCC)

1. Obtener el subgrafo alcanzable desde \(q_0\) (BFS).
2. Dividirlo en SCC (algoritmo de Tarjan o Kosaraju).
3. Para cada SCC:
   - si tiene más de 1 estado o un bucle propio, entonces contiene un ciclo;
   - verificar si desde esa SCC existe un camino hacia algún estado final.
4. Si existe al menos una SCC con ciclo y camino a final ⇒ \(L(A)\) es infinito; en caso contrario, es finito.

## 3.4 Pseudocódigo

```text
function esInfinito(DFA A):
  reachable ← BFS(q0)
  SCCs ← strongly_connected_components(reachable)

  for cada componente C en SCCs:
    if (|C| > 1) or (existe q en C con δ(q,a)=q):
      if existe camino desde C a algún f ∈ F:
        return true  # Lenguaje infinito

  return false  # No existen ciclos útiles
```

## 3.5 Ejemplo

Autómata con ciclo útil:

```
q1 -> q2
q2 -> q1   (ciclo)

Desde q2 se llega a qf (final)

➡ Lenguaje infinito.
```

Nota pedagógica: no todo ciclo implica infinitud; sólo los ciclos desde los que existe camino a aceptación.

---

# 4. Problema de Pertenencia: ¿Una cadena w ∈ L(A)?

## 4.1 Intuición

Simular el autómata sobre la cadena \(w\). Para un DFA la simulación es directa; para un NFA se trabaja con conjuntos de estados (y se debe aplicar la ε-clausura cuando corresponda).

## 4.2 Algoritmo para DFA

```text
function perteneceDFA(A, w):
  q ← q0
  for a in w:
    q ← δ(q, a)
  return q in F
```

## 4.3 Algoritmo para NFA con ε-transiciones

```text
function perteneceNFA(N, w):
  S ← epsilon_closure({q0})

  for a in w:
    T ← ∅
    for p in S:
      T ← T ∪ δ(p, a)
    S ← epsilon_closure(T)

  return (S ∩ F) ≠ ∅
```

## 4.4 Complejidad

| Tipo de autómata | Complejidad temporal |
|---|---:|
| Vacuidad / BFS, SCC | O(|Q| + |E|) ≈ O(|Q|·|Σ|) |
| Comprobación de finitud (SCC) | O(|Q| + |E|) |
| Pertenencia (DFA) | O(|w|) |
| Pertenencia (NFA, simulación con ε-clausuras) | O(|w| · (|Q| + |E|)) ≈ O(|w| · |Q| · |Σ|) |
| Conversión NFA→DFA (subconjuntos) | O(2^{|Q|}) en el peor caso (explosión exponencial) |

Comentarios:
- La verificación de vacuidad y la detección de ciclos útiles son lineales en el tamaño del grafo (estados + transiciones).
- La simulación de un DFA recorre la cadena una vez; la simulación directa de un NFA mantiene conjuntos de estados y puede costar proporcionalmente más por símbolo.

## 4.5 Ejemplo (simulación en DFA)

Autómata (simplificado):

```
q0 -a-> q1
q1 -b-> q1
q1 -c-> qf

Prueba w = a b b b c
```

Simulación:

| Paso | Estado |
|---:|:---:|
| inicio | q0 |
| a | q1 |
| b | q1 |
| b | q1 |
| b | q1 |
| c | qf |

➡ Cadena aceptada.

Error común: no aplicar la ε-clausura en NFAs que la requieren; esto produce falsos negativos.

---

# 5. Resumen General (Tabla Sintética)

| Propiedad | Método | Resultado clave |
|---|---|---|
| ¿Es vacío? | BFS/DFS desde q0 | ¿Se alcanza un estado final? |
| ¿Es finito o infinito? | SCC + análisis de ciclo | ¿Existe ciclo útil que llega a final? |
| Pertenencia de w | Simulación (DFA) / Subconjuntos (NFA) | ¿Termina en estado final (o conjunto que contiene final)? |

---

# 6. Notas finales y recomendaciones

- Prefiere siempre reducir el autómata: elimina estados inalcanzables y transiciones muertas antes de ejecutar análisis costosos.
- Para comprobaciones repetidas de pertenencia en NFAs con muchas consultas, considera convertir a DFA si el coste de la conversión es asumible; de lo contrario, usa simulación por conjuntos.
- Implementa las estructuras de datos (listas de adyacencia, bitsets para conjuntos de estados) para optimizar memoria y tiempo en implementaciones prácticas.
