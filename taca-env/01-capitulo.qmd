---
title: "Capitulo 1"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---

# 1.1 Definici√≥n formal de un DFA (Aut√≥mata Finito Determinista)

Un DFA se define formalmente como una 5‚Äìtupla:

\[
M = (Q, Œ£, Œ¥, q_0, F)
\]

donde:

* **\(Q\)** ‚Üí *Conjunto de estados:* Es un conjunto finito de estados.  
  **Ejemplo:** \(Q = \{q_0, q_1\}\)

* **\(\Œ£\)** ‚Üí *Alfabeto:* Conjunto de s√≠mbolos permitidos.  
  **Ejemplo:** \(\Œ£ = \{0, 1\}\)

* **\(\Œ¥\)** ‚Üí *Funci√≥n de transici√≥n:* Indica a qu√© estado se va dependiendo del estado actual.  
  \[
  \delta: Q \times \Sigma \rightarrow Q
  \]  
  **Ejemplo:** \(\Œ¥(q_0, 1) = q_1\)

* **\(q_0\)** ‚Üí *Estado inicial:* El estado donde empieza la m√°quina.  
  **Ejemplo:** \(q_0 = q_0\)

* **\(F\)** ‚Üí *Conjunto de estados de aceptaci√≥n:* Los estados finales o aceptadores.  
  **Ejemplo:** \(F = \{q_0\}\)

---

### Ejemplo: DFA para ‚Äúcadenas con n√∫mero par de 1‚Äôs‚Äù

El lenguaje consiste en aceptar todas las cadenas de 0‚Äôs y 1‚Äôs donde la cantidad de unos sea par.

Ejemplos aceptados:

‚úî \( \varepsilon \) (cadena vac√≠a) ‚Üí 0 unos ‚Üí par  
‚úî 0, 00, 010, 1010  

Ejemplos rechazados:

‚úò 1, 01, 001, 111 ‚Üí n√∫mero impar de unos

---

# 1.2 Idea del dise√±o

Solo necesitamos saber si la cantidad de 1‚Äôs vista hasta ahora es **par** o **impar**, por lo que basta con dos estados:

* **\(q_0\)** ‚Üí hemos visto un n√∫mero **par** de 1‚Äôs  
* **\(q_1\)** ‚Üí hemos visto un n√∫mero **impar** de 1‚Äôs

Reglas clave:

* Al leer un **1**, el DFA **cambia de estado** (alterna entre par e impar).  
* Al leer un **0**, el DFA **permanece en el mismo estado**, ya que no afecta la paridad.


## 1.3.1 Aut√≥matas Finitos Deterministas (DFAs)

### 1. Concepto Intuitivo y Operaci√≥n

Un aut√≥mata finito determinista (DFA) puede imaginarse como una m√°quina muy simple que procesa una palabra **s√≠mbolo por s√≠mbolo**, siguiendo reglas estrictas.

- **Inicio:** El aut√≥mata comienza en un estado inicial y el cabezal de lectura se coloca en la primera letra de la palabra.
- **Paso a paso:** Cada vez que lee una letra, usa su *funci√≥n de transici√≥n* para decidir a qu√© estado debe pasar.  
  Esta decisi√≥n depende **solo** del estado en el que se encuentra y de la letra le√≠da.
- **Aceptaci√≥n:** Una palabra es aceptada si, al terminar de leerla, el aut√≥mata termina en un estado que pertenece al conjunto de *estados finales*.

En pocas palabras:  
**Un DFA recorre la palabra letra por letra y cambia de estado seg√∫n reglas fijas. Si termina en un estado final, acepta; si no, la rechaza.**

---

### 2. Componentes y Transiciones

La secci√≥n describe las ideas clave del funcionamiento determinista:

- **Determinismo:**  
  Para cada combinaci√≥n `(estado, s√≠mbolo)`, existe **una √∫nica** transici√≥n posible.  
  No hay ambig√ºedad ni elecci√≥n entre varias rutas.

- **Carreras (runs):**  
  Es la secuencia de estados por los que pasa el aut√≥mata al leer la palabra completa.  
  Ejemplo:  
  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{b} q_3 \xrightarrow{b} q_2
  \]

- **Aceptaci√≥n/Rechazo:**  
  Una palabra es **aceptada** si la carrera termina en un estado final.  
  Caso contrario, es rechazada.

---

### 3. Ejemplo de la Secci√≥n 1.3.1

La secci√≥n incluye un DFA concreto:

- **Ejemplo 1.8:**  
  Se muestra el aut√≥mata:  
  \[
  A = (Q, \Sigma, \delta, q_0, F)
  \]
  donde:
  - \( Q = \{ q_0, q_1, q_2, q_3 \} \)
  - \( \Sigma = \{ a, b \} \)
  - \( F = \{ q_0 \} \) (el √∫nico estado de aceptaci√≥n)

- **Carrera de ejemplo sobre la palabra `aabb`:**

  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{b} q_3 \xrightarrow{b} q_0
  \]

  Aqu√≠, la palabra **s√≠ se acepta**, porque termina en \( q_0 \), que es estado final.

- **Estado trampa:**  
  Tambi√©n se menciona un DFA con un estado trampa, que es un estado del que no se puede salir.  
  Una vez que entras all√≠, la palabra queda autom√°ticamente rechazada.  
  Aunque existe, a veces no se dibuja en los diagramas por simplicidad.

## 1.3.2 DFAs como estructuras de datos

Los **Aut√≥matas Finitos Deterministas (DFAs)** son modelos matem√°ticos utilizados para representar sistemas capaces de reconocer patrones en cadenas de s√≠mbolos. Aunque provienen de la teor√≠a de lenguajes formales, tambi√©n se consideran **estructuras de datos**, ya que almacenan informaci√≥n de forma organizada para procesar entradas paso a paso siguiendo reglas definidas.

Desde una perspectiva computacional, un DFA es una **estructura compuesta por elementos finitos y relaciones internas**, dise√±ada para describir comportamientos secuenciales.

---

## Componentes fundamentales de un DFA

### ‚úî 1. Estados  
Un DFA contiene un conjunto finito de **estados**, cada uno representando una situaci√≥n del sistema.  
Como estructura de datos, los estados funcionan como **nodos etiquetados** que permiten recordar:

- qu√© s√≠mbolos se han procesado,
- en qu√© condici√≥n se encuentra la m√°quina.

---

### ‚úî 2. Alfabeto  
El alfabeto es el conjunto finito de s√≠mbolos v√°lidos como entrada.  
Act√∫a como un dominio de valores permitido, limitando la complejidad del procesamiento.

---

### ‚úî 3. Estado inicial  
Es el punto de partida de la m√°quina.  
Desde la perspectiva de estructura de datos, equivale a un **nodo ra√≠z** o a una variable inicializada.

---

### ‚úî 4. Estados de aceptaci√≥n  
Son estados marcados como "v√°lidos".  
Determinan si la cadena procesada es **aceptada** o **rechazada** al finalizar.

---

### ‚úî 5. Funci√≥n de transici√≥n  
La funci√≥n de transici√≥n especifica:

> ‚ÄúSi estoy en el estado X y leo el s√≠mbolo Y, voy al estado Z‚Äù.

Como estructura de datos puede representarse mediante:

- tablas,
- grafos dirigidos,
- diccionarios (clave ‚Üí valor),
- listas de adyacencia.

Es el mecanismo que almacena las reglas de movimiento.


### 1.3.2.1 Por qu√© un DFA es una estructura de datos

### üîπ 1. Almacenamiento organizado  
Un DFA guarda:

- estados,
- s√≠mbolos,
- transiciones,
- estados finales.

Todo su dise√±o es estructural: define c√≥mo se organiza y consulta la informaci√≥n.


### üîπ 2. Operaciones definidas  
La operaci√≥n principal del DFA es:

> Procesar una cadena s√≠mbolo por s√≠mbolo.

Equivale a recorrer:

- un grafo,
- una tabla,
- un mapa de transiciones.


### üîπ 3. Acceso eficiente  
Cada transici√≥n se ejecuta en **O(1)**:  
para cada par *(estado, s√≠mbolo)* hay un √∫nico destino.

Esto los hace ideales para:

- analizadores l√©xicos,
- validadores,
- reconocimiento r√°pido de patrones.


### üîπ 4. M√∫ltiples representaciones internas  
Un DFA puede almacenarse como:

- matriz de transici√≥n,
- tabla hash,
- lista de adyacencia,
- json/yaml,
- clases de programaci√≥n (Java, Python, etc.).

Esto evidencia que tambi√©n es una **estructura de datos**.


### 1.3.2.2 Interpretaci√≥n computacional

Desde el punto de vista computacional, un DFA es una **m√°quina que interpreta datos** mediante una estructura fija.

La m√°quina:

1. Recibe s√≠mbolos.
2. Recorre su estructura interna (estados y transiciones).
3. Mantiene solo una memoria finita (el estado actual).
4. Produce una salida binaria: *Aceptar* o *Rechazar*.


### 1.3.3 Aut√≥matas Finitos No Deterministas (AFND)

Hasta ahora hemos trabajado con Aut√≥matas Finitos Deterministas (AFD), donde las reglas son estrictas: para cada estado y cada s√≠mbolo existe un √∫nico camino a seguir. Sin embargo, los lenguajes m√°s complejos suelen requerir mayor flexibilidad. Aqu√≠ es donde aparece el no determinismo.

Los Aut√≥matas Finitos No Deterministas (AFND), tambi√©n conocidos simplemente como aut√≥matas no deterministas, introducen la posibilidad de elecci√≥n en el procesamiento de palabras. Esto simplifica notablemente la construcci√≥n de aut√≥matas para ciertos lenguajes.

#### Definici√≥n

Imagina que est√°s jugando ajedrez. Un AFD ser√≠a como un juego donde, ante cada posici√≥n del tablero, solo existe un movimiento legal posible: no hay elecci√≥n. En cambio, un Aut√≥mata Finito No Determinista (AFND) funciona como el ajedrez real: ante una misma situaci√≥n puedes tener m√∫ltiples movimientos posibles, o incluso ninguno.

Un AFND es un aut√≥mata finito que, al leer un s√≠mbolo de entrada, puede elegir el siguiente estado de entre un conjunto de estados candidatos.

Formalmente, un AFND es una tupla\
$A = (Q, \Sigma, \delta, Q_0, F)$, donde:

-   $Q$, $\Sigma$ y $F$ (estados, alfabeto y estados finales) son los mismos que en un AFD.
-   $Q_0$ es un conjunto no vac√≠o de estados iniciales (a diferencia del AFD, que tiene solo uno).
-   $\delta : Q \times \Sigma \to \mathcal{P}(Q)$ es la relaci√≥n de transici√≥n, que devuelve un conjunto de posibles estados siguientes.

### Ventajas sobre el AFD

El dise√±o de un AFND suele ser m√°s directo e intuitivo que el de un AFD. En un AFND no estamos obligados a definir qu√© ocurre con cada s√≠mbolo en cada estado. Si un camino no lleva a ninguna parte, simplemente "muere" sin afectar a los dem√°s recorridos. Esto nos permite modelar patrones sin preocuparnos por todas las combinaciones de errores que un AFD obligar√≠a a representar.

#### Diferencias clave con un AFD

La diferencia principal radica en el concepto de recorrido:

| Caracter√≠stica | AFD (Determinista) | AFND (No Determinista) |
|------------------------|------------------------|------------------------|
| Siguiente estado | Totalmente determinado por el estado actual y el s√≠mbolo le√≠do. | Puede elegir entre varios estados posibles. |
| Recorridos por palabra | Exactamente uno. | Puede haber cero, uno o muchos. |
| Estado inicial | Uno solo ($q_0$). | Conjunto no vac√≠o de estados iniciales ($Q_0$). |

#### C√≥mo funcionan las transiciones no deterministas

Para entenderlo, comparemos ambos modelos:

-   En un AFD, si estamos en el estado $q$ y leemos el s√≠mbolo $a$, el siguiente estado $q'$ es √∫nico:\
    $q' = \delta(q, a)$.
-   En un AFND, al estar en $q$ y leer $a$, la funci√≥n $\delta(q, a)$ devuelve un conjunto de estados posibles.\
    El aut√≥mata puede moverse a cualquiera de ellos.\
    Si $\delta(q, a) = \emptyset$, no existe un camino a seguir desde $q$ con la entrada $a$.

Un recorrido (run) de un AFND sobre una entrada $a_0 a_1 \cdots a_n$ es una secuencia\
$p_0, p_1, \ldots, p_n$ tal que:

-   $p_0 \in Q_0$
-   $p_{i+1} \in \delta(p_i, a_i)$

#### Ventajas y usos

Los AFND no aumentan el poder expresivo respecto a los AFD (reconocen los mismos lenguajes regulares), pero ofrecen ventajas importantes:

-   **Facilidad de dise√±o:** construir un AFND suele ser m√°s sencillo.
-   **Representaci√≥n natural de operaciones:** la uni√≥n de lenguajes se representa f√°cilmente mediante bifurcaci√≥n en un AFND.
-   **Aplicaciones algor√≠tmicas:** son la base para algoritmos de b√∫squeda de patrones, donde se construye un AFND a partir de una expresi√≥n regular.

#### Lenguaje reconocido

La aceptaci√≥n en un AFND es **existencial**:

Una palabra $w$ es aceptada si **al menos uno** de los posibles recorridos termina en un estado final.\
Es decir, existe un recorrido $p_0, p_1, \ldots, p_n$ tal que $p_n \in F$.

Si hay varios estados iniciales, el lenguaje reconocido es la **uni√≥n** de los lenguajes aceptados desde cada estado inicial.

En resumen: $$
L(A) = \{\, w \in \Sigma^* : w \text{ es aceptada por } A \,\}.
$$

------------------------------------------------------------------------

### 1.3.4 Aut√≥matas Finitos No Deterministas con $\epsilon$-Transiciones ($\epsilon$-AFND)

Si el AFND nos dio libertad para elegir caminos, el $\epsilon$-AFND a√±ade un ‚Äúsuperpoder‚Äù: la capacidad de moverse sin consumir ning√∫n s√≠mbolo de entrada.

Un AFND con $\epsilon$-transiciones es un aut√≥mata que permite movimientos espont√°neos, sin leer letras del alfabeto.

#### ¬øQu√© son las transiciones √©psilon?

Las $\epsilon$-transiciones son movimientos internos que el aut√≥mata puede realizar sin consumir un s√≠mbolo. Estas transiciones est√°n etiquetadas con la palabra vac√≠a $\epsilon$.

#### C√≥mo funcionan y por qu√© son importantes

Un AFND est√°ndar solo puede cambiar de estado al leer una letra del alfabeto. Un $\epsilon$-AFND puede cambiar de estado al leer una letra o al ejecutar una $\epsilon$-transici√≥n.

Un AFND solo puede cambiar de estado al leer un s√≠mbolo del alfabeto.\
Un $\epsilon$-AFND puede cambiar de estado:

-   al leer un s√≠mbolo, o ejecutando una transici√≥n $\epsilon$.

La relaci√≥n de transici√≥n se extiende: $$
\delta : Q \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q).
$$

Una palabra $a_1 a_2 \cdots a_n$ es aceptada si existe un recorrido que consume exactamente esa palabra, permitiendo cualquier n√∫mero de transiciones $\epsilon$ antes, entre o despu√©s de los s√≠mbolos.

Estas transiciones son esenciales en algoritmos de conversi√≥n, por ejemplo, al traducir expresiones regulares a aut√≥matas.

#### Diferencias entre AFND y $\epsilon$-AFND

La diferencia est√° en la relaci√≥n de transici√≥n:

-   En el AFND, solo hay transiciones con s√≠mbolos de $\Sigma$.\
-   En el $\epsilon$-AFND, tambi√©n puede haber transiciones etiquetadas con $\epsilon$.

### Analog√≠a constructiva: ‚ÄúEl edificio y los andamios‚Äù

Construir un AFD es como levantar un edificio colocando ladrillos definitivos desde el inicio.\
Construir un $\epsilon$-AFND es como usar andamios: las transiciones $\epsilon$ permiten unir partes del aut√≥mata de forma modular y flexible.

### Explicaci√≥n de la $\epsilon$-cerradura (epsilon-closure)

La $\epsilon$-cerradura de un estado $q$ es el conjunto de todos los estados accesibles desde $q$ usando √∫nicamente transiciones $\epsilon$.

Este concepto es crucial para eliminar $\epsilon$-transiciones y convertir un $\epsilon$-AFND en un AFND est√°ndar.


## 1.3.5 & 1.3.6: NFA con Expresiones Regulares y Forma Normal para Aut√≥matas

## Introducci√≥n

En el estudio de los lenguajes regulares, podemos describir un lenguaje de dos formas complementarias:

- **Forma Descriptiva**: Mediante **Expresiones Regulares** (dicen *qu√©* cadenas pertenecen al lenguaje)
- **Forma Reconocedora**: Mediante **Aut√≥matas Finitos** (muestran *c√≥mo* reconocer si una cadena pertenece al lenguaje)

---

## 1.3.5 Equivalencia entre NFA y Expresiones Regulares

### El Teorema de Kleene

**Teorema**: Un lenguaje es regular si y solo si puede ser descrito por una expresi√≥n regular.

> Para cualquier Expresi√≥n Regular *R*, existe un NFA *N* tal que *L(N) = L(R)*.
> 
> **Inversamente**: Para cualquier NFA *N*, existe una expresi√≥n regular *R* tal que *L(R) = L(N)*.

Esto significa que ambas representaciones son **igualmente expresivas**.

---

### Conversi√≥n: De Expresi√≥n Regular a NFA (Construcci√≥n de Thompson)

El m√©todo m√°s conocido es la **Construcci√≥n de Thompson**, que construye bloques b√°sicos de aut√≥matas y los combina usando operaciones correspondientes a los operadores de expresiones regulares.

#### Construcciones B√°sicas

**1. Cadena vac√≠a (Œµ):** Un aut√≥mata con estado inicial que transita directamente al estado final mediante Œµ.

**2. S√≠mbolo del alfabeto (a):** Un aut√≥mata que lee exactamente el s√≠mbolo 'a' y transita del inicial al final.

**3. Lenguaje vac√≠o (‚àÖ):** Un aut√≥mata donde el estado inicial no tiene forma de llegar al final.

#### Operaciones Compuestas

**1. Uni√≥n (R‚ÇÅ ‚à™ R‚ÇÇ):**
- Crear un nuevo estado inicial con dos transiciones Œµ: una hacia el aut√≥mata de *R‚ÇÅ* y otra hacia el de *R‚ÇÇ*
- Crear un nuevo estado final
- Conectar ambos aut√≥matas finales al nuevo estado final mediante Œµ
- El aut√≥mata puede "elegir" no determin√≠sticamente cu√°l camino tomar

**2. Concatenaci√≥n (R‚ÇÅR‚ÇÇ):**
- Conectar los estados de aceptaci√≥n de *NFA‚ÇÅ* con el estado inicial de *NFA‚ÇÇ* mediante transiciones Œµ
- El estado inicial es el de *NFA‚ÇÅ* y el estado final es el de *NFA‚ÇÇ*
- La transici√≥n Œµ permite "continuar" desde donde termin√≥ *R‚ÇÅ* hacia *R‚ÇÇ*

**3. Cerradura de Kleene (R*):**
- Crear un nuevo estado inicial y uno final
- A√±adir una transici√≥n Œµ directa del nuevo inicial al nuevo final (para aceptar Œµ)
- Conectar el nuevo inicial con el antiguo inicial del aut√≥mata de *R*
- Conectar el antiguo final de *R* con el nuevo final
- A√±adir una transici√≥n Œµ del antiguo final al antiguo inicial (permitiendo repetir)

**Ejemplo:** Para la expresi√≥n regular `(a|b)*c`:
1. Construir aut√≥matas para 'a' y 'b'
2. Unirlos (operaci√≥n |)
3. Aplicar Kleene (*) al resultado
4. Concatenar con el aut√≥mata para 'c'

---

## 1.3.6 Forma Normal para Aut√≥matas

### El Problema

Para convertir un NFA en una Expresi√≥n Regular, necesitamos estandarizar el aut√≥mata, ya que un NFA t√≠pico puede tener:
- M√∫ltiples estados de aceptaci√≥n
- Ciclos complejos
- Transiciones desde y hacia el estado inicial
- Estructuras dif√≠ciles de "leer" como expresiones regulares

---

### GNFA (Aut√≥mata Finito No Determinista Generalizado)

Un **GNFA** es un aut√≥mata en forma normal que cumple con:

**1. Estado Inicial √önico:**
- Un √∫nico estado inicial sin transiciones entrantes
- Solo tiene transiciones salientes
- Garantiza que el aut√≥mata "comience limpiamente"

**2. Estado Final √önico:**
- Un √∫nico estado de aceptaci√≥n sin transiciones salientes
- Solo tiene transiciones entrantes
- Garantiza que la aceptaci√≥n sea un punto final definido

**3. Transiciones Generalizadas:**
- Las etiquetas de las transiciones son **Expresiones Regulares completas**
- Ejemplo: una transici√≥n puede estar etiquetada como `(a|b)*c`

**4. Completitud:**
- Entre cada par de estados puede haber a lo sumo una transici√≥n
- Si no existe transici√≥n f√≠sica, se considera una transici√≥n etiquetada con ‚àÖ

---

### Proceso de Normalizaci√≥n

#### Paso 1: Crear Estado Inicial √önico

Si el estado inicial tiene transiciones entrantes:
- Crear un nuevo estado inicial
- A√±adir una transici√≥n Œµ desde el nuevo inicial hacia el antiguo estado inicial

#### Paso 2: Crear Estado Final √önico

Si hay m√∫ltiples estados de aceptaci√≥n:
- Crear un nuevo estado final √∫nico
- Desde cada antiguo estado de aceptaci√≥n, a√±adir una transici√≥n Œµ hacia el nuevo estado final
- Solo el nuevo estado es de aceptaci√≥n

#### Paso 3: Convertir a Transiciones Generalizadas

Si hay m√∫ltiples transiciones entre los mismos dos estados, combinarlas en una sola transici√≥n etiquetada con la uni√≥n de todas las etiquetas.

**Ejemplo:** Si hay transiciones con 'a' y 'b' entre q‚ÇÅ y q‚ÇÇ, se combinan en una transici√≥n etiquetada con `(a|b)`.

---

### Algoritmo de Eliminaci√≥n de Estados

Una vez que el aut√≥mata est√° en Forma Normal (GNFA), se aplica el **algoritmo de Eliminaci√≥n de Estados**:

#### Objetivo

Eliminar estados intermedios uno por uno, "recableando" las transiciones para preservar el lenguaje, hasta que solo queden el estado inicial y el final.

#### Proceso de Eliminaci√≥n

Cuando eliminamos un estado *q_rip*, para cada par de estados (*q_i*, *q_j*) donde:
- Hay una transici√≥n de *q_i* a *q_rip* etiquetada con *R‚ÇÅ*
- Hay una transici√≥n de *q_rip* a *q_j* etiquetada con *R‚ÇÇ*
- Hay un ciclo en *q_rip* etiquetado con *R‚ÇÉ*
- Ya existe una transici√≥n directa de *q_i* a *q_j* etiquetada con *R‚ÇÑ*

**Nueva transici√≥n:** `R_nueva = R‚ÇÑ | R‚ÇÅR‚ÇÉ*R‚ÇÇ`

**Explicaci√≥n:**
- `R‚ÇÅ`: Lo necesario para llegar a *q_rip* desde *q_i*
- `R‚ÇÉ*`: Puede quedarse en *q_rip* cero o m√°s veces (el ciclo)
- `R‚ÇÇ`: Lo necesario para salir de *q_rip* hacia *q_j*
- `R‚ÇÑ`: La ruta directa que ya exist√≠a
- `|`: Uni√≥n (cualquiera de las dos opciones funciona)

#### Pasos Completos

1. Normalizar el NFA a GNFA
2. Mientras haya m√°s de 2 estados:
   - Elegir un estado intermedio (ni inicial ni final)
   - Calcular las nuevas expresiones regulares para cada combinaci√≥n de estados
   - Eliminar el estado intermedio y sus transiciones
3. La expresi√≥n regular en la transici√≥n entre el inicial y el final es la **expresi√≥n regular equivalente** al NFA original

---

## Ejemplo de Conversi√≥n

**NFA que acepta cadenas que terminan en 'b':**
- Estados: {q‚ÇÄ, q‚ÇÅ}
- Inicial: q‚ÇÄ
- Finales: {q‚ÇÅ}
- Transiciones: q‚ÇÄ --a--> q‚ÇÄ, q‚ÇÄ --b--> q‚ÇÄ, q‚ÇÄ --b--> q‚ÇÅ

**Proceso:**
1. Normalizar: A√±adir nuevo estado inicial y final √∫nico con transiciones Œµ
2. Generalizar transiciones: Combinar transiciones con 'a' y 'b' en q‚ÇÄ como `(a|b)`
3. Eliminar q‚ÇÄ: Calcular expresi√≥n para ir de q_start a q‚ÇÅ pasando por q‚ÇÄ
   - Entrada: Œµ, Loop: (a|b), Salida: b
   - Expresi√≥n: `Œµ(a|b)*b = (a|b)*b`
4. Eliminar q‚ÇÅ: Simplificar

**Resultado:** La expresi√≥n regular equivalente es `(a|b)*b`

## 1.4.1 Algoritmo: De NFA a DFA

### Definiciones y notaci√≥n b√°sica

Sea un aut√≥mata finito no determinista con (posibles) transiciones Œµ:
\(
\mathcal{A} = (Q, \Sigma, \delta, q_0, F),
\)
donde:
- \(Q\): conjunto finito de **estados**.
- \(\Sigma\): **alfabeto** de entrada.
- \(\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to \mathcal{P}(Q)\): funci√≥n de **transici√≥n** (posiblemente con Œµ).
- \(q_0 \in Q\): **estado inicial**.
- \(F \subseteq Q\): conjunto de **estados de aceptaci√≥n**.

Un **DFA** es \(\mathcal{A}' = (Q', \Sigma, \delta', q'_0, F')\) con:
- \(Q' \subseteq \mathcal{P}(Q)\) (subconjuntos de \(Q\)).
- \(\delta': Q' \times \Sigma \to Q'\) **total** (definida para todo par).
- \(q'_0 = \varepsilon\text{-closure}(\{q_0\})\).
- \(F' = \{S \in Q' \mid S \cap F \neq \varnothing\}\).

**Œµ‚Äìcierre**: \(\varepsilon\text{-closure}(S)\) es el conjunto de estados alcanzables desde cualquiera en \(S\) usando solo transiciones Œµ (incluye \(S\)).

# Algoritmo (Construcci√≥n de Subconjuntos)

**Entrada:** NFA (o Œµ‚ÄìNFA) \((Q,\Sigma,\delta,q_0,F)\).  
**Salida:** DFA equivalente \((Q',\Sigma,\delta',q'_0,F')\).

1. **Inicializaci√≥n.**  
   \(q'_0 \leftarrow \varepsilon\text{-closure}(\{q_0\})\). Encola \(q'_0\) como no procesado.  
   \(Q' \leftarrow \{q'_0\}\), \(F' \leftarrow \emptyset\).

2. **Bucle principal.** Mientras exista un subconjunto \(S \subseteq Q\) sin procesar:
   1. Para cada s√≠mbolo \(a \in \Sigma\):
      - \(U \leftarrow \varepsilon\text{-closure}\Big(\bigcup_{p \in S} \delta(p,a)\Big)\).
      - Si \(U = \emptyset\), marca transici√≥n a **estado trampa** \( \bot \).  
        (Si \( \bot \notin Q' \), a√±√°delo y define \(\delta'(\bot,a)=\bot\) para todo \(a\).)
      - Si \(U \notin Q'\), a√±ade \(U\) a \(Q'\) y encola \(U\).
      - Define \(\delta'(S,a)=U\) (o \(\bot\) si vac√≠o).
   2. Si \(S \cap F \neq \varnothing\), a√±ade \(S\) a \(F'\).  
   3. Marca \(S\) como procesado.

3. **Resultado.** Devuelve \((Q',\Sigma,\delta',q'_0,F')\).

## Comentarios pr√°cticos

- El **estado trampa** (dead state) asegura que \(\delta'\) sea **total**.  
- En la implementaci√≥n conviene **ordenar**/**congelar** subconjuntos (por ejemplo, como tuplas ordenadas) para compararlos y guardarlos en tablas o diccionarios.
- El n√∫mero de estados del DFA puede ser hasta \(2^{|Q|}\) en el peor caso; en la pr√°ctica, solo se generan los **accesibles** desde \(q'_0\).

# Ejemplo trabajado

Considere el Œµ‚ÄìNFA que reconoce \(L = \{\,ab^*\,\} \cup \{\,ba^*\,\}\) sobre \(\Sigma=\{a,b\}\). Una especificaci√≥n posible (sin Œµ para simplificar) es:

- \(Q=\{0,1,2,3,4\}\), \(q_0=0\), \(F=\{2,4\}\).
- Transiciones:
  - Desde 0 con **a** ‚Üí {1}; desde 1 con **b** ‚Üí {1,2}; (1 acepta si luego llega a 2 por b-que-finaliza).
  - Desde 0 con **b** ‚Üí {3}; desde 3 con **a** ‚Üí {3,4}.

Tabla de construcci√≥n (borrador ilustrativo):

| Conjunto \(S\) | con **a** | con **b** | ¬øAcepta? |
|---|---|---|---|
| {0} | {1} | {3} | No |
| {1} | ‚àÖ | {1,2} | **Depende** (si incluye 2) |
| {3} | {3,4} | ‚àÖ | **Depende** (si incluye 4) |
| {1,2} | ‚àÖ | {1,2} | **S√≠** |
| {3,4} | {3,4} | ‚àÖ | **S√≠** |
| ‚àÖ ‚Üí **trampa** | trampa | trampa | No |

La partici√≥n de aceptaci√≥n surge porque todo subconjunto que contenga 2 o 4 es aceptante.

> Puedes rehacer este ejemplo con tu propio NFA/Œµ‚ÄìNFA y seguir el algoritmo para obtener la tabla definitiva del DFA (con nombres de estado renombrados A, B, C, ‚Ä¶ si lo prefieres).

# Pseudoc√≥digo

```text
function subset_construction(NFA):
    Q, Sigma, delta, q0, F = NFA
    start = eps_closure({q0})
    work = queue([start])
    Qp = {start}
    Fp = {}
    for each a in Sigma: delta_p[trap][a] = trap  # define trampa

    while work not empty:
        S = work.pop()
        if S ‚à© F ‚â† ‚àÖ: Fp.add(S)
        for a in Sigma:
            U = eps_closure( ‚ãÉ_{p‚ààS} delta(p, a) )
            if U = ‚àÖ:
                delta_p[S][a] = trap
            else:
                if U not in Qp: Qp.add(U); work.push(U)
                delta_p[S][a] = U

    return (Qp, Sigma, delta_p, start, Fp)
```

# Implementaci√≥n de referencia (Python)

```python
from collections import deque, defaultdict

def eps_closure(states, delta_eps):
    # delta_eps: dict[state] -> set[states] of epsilon-transitions
    stack = list(states)
    seen = set(states)
    while stack:
        s = stack.pop()
        for t in delta_eps.get(s, set()):
            if t not in seen:
                seen.add(t)
                stack.append(t)
    return frozenset(seen)

def nfa_to_dfa(Q, Sigma, delta, delta_eps, q0, F):
    # delta: dict[(state, symbol)] -> set[states]
    start = eps_closure({q0}, delta_eps)
    trap = frozenset()  # represent trampa como vac√≠o
    dfa_delta = {}
    Qp = set([start])
    Fp = set()
    work = deque([start])

    while work:
        S = work.popleft()
        if any(s in F for s in S):
            Fp.add(S)
        for a in Sigma:
            # mover con 'a' y luego epsilon-cierre
            next_states = set()
            for p in S:
                next_states |= delta.get((p, a), set())
            U = eps_closure(next_states, delta_eps)
            if len(U) == 0:
                dfa_delta[(S, a)] = trap
            else:
                dfa_delta[(S, a)] = U
                if U not in Qp:
                    Qp.add(U)
                    work.append(U)

    # completar funci√≥n total agregando lazo en trampa
    for a in Sigma:
        dfa_delta[(trap, a)] = trap

    return Qp, Sigma, dfa_delta, start, Fp

# Ejemplo m√≠nimo sin epsilon (delta_eps vac√≠o)
Q = {0,1,2,3,4}
Sigma = {'a','b'}
delta = {
    (0,'a'):{1}, (1,'b'):{1,2},
    (0,'b'):{3}, (3,'a'):{3,4},
}
delta_eps = {}  # sin epsilon
q0 = 0
F = {2,4}

Qp, Sigma, dfa_delta, start, Fp = nfa_to_dfa(Q,Sigma,delta,delta_eps,q0,F)

# Muestra legible
def name(S):
    return "‚àÖ" if len(S)==0 else "{" + ",".join(map(str,sorted(S))) + "}"

print("Estado inicial DFA:", name(start))
print("Estados de aceptaci√≥n:", [name(S) for S in Fp])
print("\nTransiciones DFA:")
for (S,a),U in sorted(dfa_delta.items(), key=lambda x:(sorted(list(x[0][0])) if x[0][0] else [-1], x[0][1])):
    print(f" Œ¥({name(S)}, {a}) = {name(U)}")
```

# Complejidad

- **Tiempo:** en el peor caso \(O(2^{|Q|} \cdot |\Sigma| \cdot |Q|)\) debido a exploraci√≥n de subconjuntos y c√°lculos de Œµ‚Äìcierre.
- **Espacio:** hasta \(O(2^{|Q|})\) estados; en pr√°ctica, suele ser mucho menor si el NFA es esparso.

# Buenas pr√°cticas

- Normaliza nombres de estados del DFA para reportes (A, B, C, ‚Ä¶).
- Implementa **minimizaci√≥n de DFA** despu√©s de la construcci√≥n para reducir estados.
- Escribe pruebas con **cadenas test** y comprueba aceptaci√≥n en ambos aut√≥matas.

# Ejercicios propuestos

1. Convierte a DFA un Œµ‚ÄìNFA para el lenguaje de cadenas sobre \(\{0,1\}\) que contienen **al menos un 1**.
2. Repite el ejemplo de \(\{ab^*\} \cup \{ba^*\}\) pero con un dise√±o de NFA alternativo, y verifica que ambos DFA aceptan el mismo lenguaje.
3. Agrega Œµ‚Äìtransiciones a tu NFA y verifica que el resultado del DFA sea equivalente (usa Œµ‚Äìcierre).
4. Minimiza el DFA obtenido y compara el n√∫mero de estados.



## 1.4.2 Algoritmo: De NFA-Œµ a NFA

La conversi√≥n de un Aut√≥mata Finito No Determinista con transiciones Œµ (AFND-Œµ) a un Aut√≥mata Finito No Determinista (AFND) es un procedimiento fundamental para demostrar que ambos modelos reconocen la misma clase de lenguajes regulares.

En esta secci√≥n se presenta el **Algoritmo 2: `NFAŒµtoNFA`**, el cual permite eliminar todas las transiciones Œµ manteniendo el mismo lenguaje reconocido.

---

### 1.4.2.1 Conceptos Fundamentales

Un **AFND-Œµ** permite realizar transiciones espont√°neas mediante el s√≠mbolo Œµ, sin consumir entrada.  
El objetivo del algoritmo es construir un **AFND equivalente**, es decir, un aut√≥mata que:

- no utilice transiciones Œµ,
- y reconozca el mismo lenguaje:
  
  $$L(A) = L(B).$$

La idea principal de la conversi√≥n consiste en reemplazar cada transici√≥n Œµ por **atajos** directos:

Si

$$q_1 \xrightarrow{\epsilon} q_2, \qquad q_2 \xrightarrow{a} q_3,$$

entonces se crea la transici√≥n:

$$q_1 \xrightarrow{a} q_3.$$

El algoritmo `NFAŒµtoNFA` realiza este proceso en **una sola pasada**, utilizando un conjunto de trabajo (*workset*) y aplicando simult√°neamente saturaci√≥n, propagaci√≥n y eliminaci√≥n de transiciones Œµ.

---

### 1.4.2.2 Definici√≥n Formal del Algoritmo NFAŒµtoNFA

Sea un AFND-Œµ:

$$A = (Q, \Sigma, \delta, Q_0, F),$$

el algoritmo construye un AFND equivalente sin transiciones Œµ:

$$B = (Q', \Sigma, \delta', Q'_0, F').$$

---

#### 1.4.2.2.1 Inicializaci√≥n

1. **Estados iniciales:**

   $$Q'_0 \leftarrow Q_0.$$

2. **Conjunto de estados y transiciones del nuevo aut√≥mata:**

   $$Q' \leftarrow Q_0, \qquad \delta' \leftarrow \emptyset.$$

3. **Estados finales iniciales:**

   $$F' \leftarrow F \cap Q_0.$$

4. **Conjunto de trabajo inicial:**

   $$W \leftarrow \{(q,\alpha,q')\in\delta : q\in Q_0\}.$$

5. **Almac√©n temporal de transiciones Œµ:**

   $$\delta'' \leftarrow \emptyset.$$

---

#### 1.4.2.2.2 Bucle de Conversi√≥n

Mientras el conjunto de trabajo \(W\) no est√© vac√≠o, extraer una transici√≥n \((q_1, \alpha, q_2)\) y procesarla seg√∫n los siguientes casos.

---

#### 1.4.2.2.3 Caso A: Transici√≥n con S√≠mbolo (\(\alpha \neq \epsilon\))

1. A√±adir \(q_2\) a \(Q'\) y la transici√≥n \((q_1,\alpha,q_2)\) a \(\delta'\).
2. Si \(q_2 \in F\), a√±adirlo a \(F'\).
3. **Propagaci√≥n del s√≠mbolo:**  
   Para cada transici√≥n:

   $$q_2 \xrightarrow{\epsilon} q_3,$$

   a√±adir al conjunto de trabajo:

   $$(q_1, \alpha, q_3).$$

4. A√±adir a \(W\) todas las transiciones salientes de \(q_2\) cuyo s√≠mbolo est√© en \(\Sigma\).

---

#### 1.4.2.2.4 Caso B: Transici√≥n Vac√≠a (\(\alpha = \epsilon\))

1. Guardar la transici√≥n en \(\delta''\).
2. **Œµ-check:**  
   Si \(q_2 \in F\), marcar \(q_1\) como final:

   $$q_1 \in F'.$$

3. **Creaci√≥n de atajos:**  
   Para cada transici√≥n:

   $$q_2 \xrightarrow{\beta} q_3, \quad (\beta \in \Sigma \cup \{\epsilon\}),$$

   a√±adir al conjunto de trabajo:

   $$(q_1, \beta, q_3).$$

---

### 1.4.2.3 Mecanismo Œµ-check y Preservaci√≥n de la Aceptaci√≥n de Œµ

El algoritmo debe conservar la aceptaci√≥n de la palabra vac√≠a Œµ.

Si un estado inicial puede llegar a un estado final utilizando √∫nicamente transiciones Œµ, entonces dicho estado debe considerarse final en el AFND resultante:

$$\text{Si } q_2 \in F \Rightarrow q_1 \in F'.$$

Sin esta verificaci√≥n, la eliminaci√≥n de Œµ podr√≠a impedir que el aut√≥mata siga aceptando Œµ, aun cuando el original s√≠ lo hac√≠a.

---

### 1.4.2.4 Ejemplo de Aplicaci√≥n del Algoritmo

#### 1.4.2.4.1 Descripci√≥n del AFND-Œµ

Considere un AFND-Œµ con:

- Estados: \(\{p, q, r, s\}\)
- Alfabeto: \(\Sigma = \{a, b\}\)
- Estado inicial: \(p\)
- Estado final: \(s\)

Transiciones:

- \( p \xrightarrow{\epsilon} q \)
- \( q \xrightarrow{\epsilon} r \)
- \( r \xrightarrow{\epsilon} s \)
- \( q \xrightarrow{a} q \)
- \( r \xrightarrow{b} s \)

---

#### 1.4.2.4.2 Ejecuci√≥n del Algoritmo

| Iteraci√≥n | Transici√≥n procesada | S√≠mbolo | Nuevos elementos a√±adidos a W | A√±adido a Œ¥' | Observaciones |
|----------:|----------------------|---------|-------------------------------|--------------|---------------|
| **0** | Inicializaci√≥n | ‚Äì | (p,Œµ,q), (p,Œµ,r) | ‚àÖ | Se llena el conjunto de trabajo inicial. |
| **1** | (p,Œµ,q) | Œµ | (p,a,q), (p,b,s), (p,Œµ,r), (p,Œµ,s) | ‚àÖ | Propagaci√≥n desde q. |
| **2** | (p,Œµ,r) | Œµ | (p,b,s), (p,Œµ,s) | ‚àÖ | Propagaci√≥n desde r. |
| **3** | (p,a,q) | a | ‚Äì | (p,a,q) | Se a√±ade transici√≥n directa. |
| **4** | (p,b,s) | b | ‚Äì | (p,b,s) | Se a√±ade transici√≥n directa y se marca s como final. |
| ‚Ä¶ | Contin√∫a | | ‚Äì | (q,a,q), (q,b,s) | Transiciones finales sin Œµ. |

---

### 1.4.2.5 Resultado Final

Tras completar el algoritmo:

- todas las transiciones Œµ han sido eliminadas,
- los atajos necesarios fueron generados,
- y el AFND resultante contiene √∫nicamente transiciones con s√≠mbolos del alfabeto.

El aut√≥mata obtenido es completamente equivalente al AFND-Œµ original.

---

## 1.4.3 Conversi√≥n de NFA-reg a NFA-$\varepsilon$

El proceso para transformar un **NFA con Expresiones Regulares (NFA-reg)** en un **NFA con Transiciones Epsilon (NFA-$\varepsilon$)** que reconozca el mismo lenguaje se realiza en dos pasos.

---

### Conceptos Clave y S√≠mbolos

Antes de entrar en el proceso, es fundamental entender la notaci√≥n utilizada:

* **NFA-reg (NFA con Expresiones Regulares):** Un Aut√≥mata Finito No Determinista (NFA) donde las transiciones est√°n etiquetadas por **expresiones regulares completas** (ej., $a^*b + c$).
* **NFA-$\varepsilon$ (NFA con Transiciones Epsilon):** Un NFA est√°ndar donde las transiciones solo est√°n etiquetadas por **s√≠mbolos individuales del alfabeto ($\Sigma$) o por la cadena vac√≠a ($\varepsilon$)**.
* **Transici√≥n $\varepsilon$:** Permite al aut√≥mata cambiar de estado **sin consumir ning√∫n s√≠mbolo** de la cadena de entrada.  Esto es vital para simular las operaciones complejas de las expresiones regulares.
* **$\varepsilon$ (Cadena Vac√≠a):** La cadena de longitud cero.
* **$\emptyset$ (Lenguaje Vac√≠o):** El lenguaje que no contiene ninguna cadena.
* **$\rightsquigarrow$ (Reescritura):** Indica que la expresi√≥n de la izquierda es sustituida por la derecha.

---

### 1. Preprocesamiento de Expresiones Regulares

Se simplifican las etiquetas de las transiciones (expresiones regulares $r$) mediante la aplicaci√≥n exhaustiva de las siguientes reglas de reescritura. Estas reglas se basan en la eliminaci√≥n del s√≠mbolo del lenguaje vac√≠o ($\emptyset$).

* $r \cdot \emptyset \rightsquigarrow \emptyset$ (Cualquier cosa concatenada con $\emptyset$ es $\emptyset$)
* $\emptyset \cdot r \rightsquigarrow \emptyset$
* $r + \emptyset \rightsquigarrow r$ (La uni√≥n con $\emptyset$ no a√±ade nada)
* $\emptyset + r \rightsquigarrow r$
* $\emptyset^* \rightsquigarrow \varepsilon$ (Cero o m√°s repeticiones de la nada es la cadena vac√≠a)

Dado que el lado izquierdo y derecho de cada regla denotan el mismo lenguaje, la expresi√≥n regular despu√©s del preprocesamiento es equivalente.

Una transici√≥n de un NFA-reg etiquetada por $\emptyset$ puede ser **eliminada** sin cambiar el lenguaje del aut√≥mata. Despu√©s de la eliminaci√≥n, el NFA-reg restante solo tendr√° etiquetas que no contengan el s√≠mbolo $\emptyset$.

### 2. Aplicaci√≥n de Reglas de Transformaci√≥n

Se aplican exhaustivamente las **reglas de transformaci√≥n** (Figura 1.16) para descomponer cada expresi√≥n regular en sus constituyentes m√°s simples (concatenaci√≥n, uni√≥n, cerradura de Kleene, s√≠mbolos $\Sigma$, o $\varepsilon$). 

* **Principio:** Cada regla preserva el lenguaje reconocido, reemplazando una transici√≥n con una expresi√≥n compleja por un sub-aut√≥mata equivalente usando transiciones m√°s simples (s√≠mbolos $\Sigma$ o $\varepsilon$). Por ejemplo, la regla para la cerradura de Kleene ($r^*$) introduce dos transiciones $\varepsilon$ para garantizar la equivalencia, incluso si el estado fuente y destino de la transici√≥n original tienen otras entradas o salidas.

Como cada regla descompone una expresi√≥n en sus componentes (por ejemplo, $r_1 \cdot r_2$ se descompone en $r_1$ y $r_2$), se garantiza que el proceso **finaliza**. El aut√≥mata resultante no tendr√° transiciones etiquetadas con expresiones regulares compuestas, sino solo con letras de $\Sigma$ o con $\varepsilon$, siendo por definici√≥n un **NFA-$\varepsilon$**.

#### Ejemplo 1.20

Consideremos la expresi√≥n regular $(a^*b^* + c)^*d$. La Figura 1.17 muestra el resultado de aplicar las reglas de transformaci√≥n de manera iterativa hasta obtener un NFA-$\varepsilon$.

---

### Complejidad y Eficiencia (An√°lisis del Costo)

Se define una medida de complejidad $l(r)$ para una expresi√≥n regular $r$:

$$
l(\emptyset) = l(\varepsilon) = l(a) = 0 \\
l(r_1\cdot r_2) = l(r_1+r_2) = l(r_1)+l(r_2)+1 \\
l(r^*) = l(r)+1
$$

La complejidad de un NFA-reg $A$ es la suma de las complejidades de sus etiquetas: $l(A) = \sum_{(q,r,q')\in\delta} l(r)$.

* Cada aplicaci√≥n de una regla de transformaci√≥n produce un aut√≥mata $A'$ tal que **$l(A') = l(A)-1$**. Esto significa que en cada paso la complejidad se reduce en exactamente una unidad.
* El proceso termina cuando $l(A') = 0$, que es cuando $A'$ es un NFA-$\varepsilon$ (solo transiciones at√≥micas).
* Por lo tanto, se obtiene un NFA-$\varepsilon$ despu√©s de $l(A)$ aplicaciones de reglas, con a lo sumo $|Q| + l(A)$ estados.
* La conversi√≥n se ejecuta en **tiempo lineal** ($O(l(A))$), asegurando que el proceso es eficiente.

