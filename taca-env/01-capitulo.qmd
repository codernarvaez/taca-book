---
title: "Capitulo 1"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---

# 1.1 Definici√≥n formal de un DFA (Aut√≥mata Finito Determinista)

Un DFA se define formalmente como una 5‚Äìtupla:

\[
M = (Q, Œ£, Œ¥, q_0, F)
\]

donde:

* **\(Q\)** ‚Üí *Conjunto de estados:* Es un conjunto finito de estados.  
  **Ejemplo:** \(Q = \{q_0, q_1\}\)

* **\(\Œ£\)** ‚Üí *Alfabeto:* Conjunto de s√≠mbolos permitidos.  
  **Ejemplo:** \(\Œ£ = \{0, 1\}\)

* **\(\Œ¥\)** ‚Üí *Funci√≥n de transici√≥n:* Indica a qu√© estado se va dependiendo del estado actual.  
  \[
  \delta: Q \times \Sigma \rightarrow Q
  \]  
  **Ejemplo:** \(\Œ¥(q_0, 1) = q_1\)

* **\(q_0\)** ‚Üí *Estado inicial:* El estado donde empieza la m√°quina.  
  **Ejemplo:** \(q_0 = q_0\)

* **\(F\)** ‚Üí *Conjunto de estados de aceptaci√≥n:* Los estados finales o aceptadores.  
  **Ejemplo:** \(F = \{q_0\}\)

---

### Ejemplo: DFA para ‚Äúcadenas con n√∫mero par de 1‚Äôs‚Äù

El lenguaje consiste en aceptar todas las cadenas de 0‚Äôs y 1‚Äôs donde la cantidad de unos sea par.

Ejemplos aceptados:

‚úî \( \varepsilon \) (cadena vac√≠a) ‚Üí 0 unos ‚Üí par  
‚úî 0, 00, 010, 1010  

Ejemplos rechazados:

‚úò 1, 01, 001, 111 ‚Üí n√∫mero impar de unos

---

# 1.2 Idea del dise√±o

Solo necesitamos saber si la cantidad de 1‚Äôs vista hasta ahora es **par** o **impar**, por lo que basta con dos estados:

* **\(q_0\)** ‚Üí hemos visto un n√∫mero **par** de 1‚Äôs  
* **\(q_1\)** ‚Üí hemos visto un n√∫mero **impar** de 1‚Äôs

Reglas clave:

* Al leer un **1**, el DFA **cambia de estado** (alterna entre par e impar).  
* Al leer un **0**, el DFA **permanece en el mismo estado**, ya que no afecta la paridad.


## 1.3.1 Aut√≥matas Finitos Deterministas (DFAs)

### 1. Concepto Intuitivo y Operaci√≥n

Un aut√≥mata finito determinista (DFA) puede imaginarse como una m√°quina muy simple que procesa una palabra **s√≠mbolo por s√≠mbolo**, siguiendo reglas estrictas.

- **Inicio:** El aut√≥mata comienza en un estado inicial y el cabezal de lectura se coloca en la primera letra de la palabra.
- **Paso a paso:** Cada vez que lee una letra, usa su *funci√≥n de transici√≥n* para decidir a qu√© estado debe pasar.  
  Esta decisi√≥n depende **solo** del estado en el que se encuentra y de la letra le√≠da.
- **Aceptaci√≥n:** Una palabra es aceptada si, al terminar de leerla, el aut√≥mata termina en un estado que pertenece al conjunto de *estados finales*.

En pocas palabras:  
**Un DFA recorre la palabra letra por letra y cambia de estado seg√∫n reglas fijas. Si termina en un estado final, acepta; si no, la rechaza.**

---

### 2. Componentes y Transiciones

La secci√≥n describe las ideas clave del funcionamiento determinista:

- **Determinismo:**  
  Para cada combinaci√≥n `(estado, s√≠mbolo)`, existe **una √∫nica** transici√≥n posible.  
  No hay ambig√ºedad ni elecci√≥n entre varias rutas.

- **Carreras (runs):**  
  Es la secuencia de estados por los que pasa el aut√≥mata al leer la palabra completa.  
  Ejemplo:  
  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{b} q_3 \xrightarrow{b} q_2
  \]

- **Aceptaci√≥n/Rechazo:**  
  Una palabra es **aceptada** si la carrera termina en un estado final.  
  Caso contrario, es rechazada.

---

### 3. Ejemplo de la Secci√≥n 1.3.1

La secci√≥n incluye un DFA concreto:

- **Ejemplo 1.8:**  
  Se muestra el aut√≥mata:  
  \[
  A = (Q, \Sigma, \delta, q_0, F)
  \]
  donde:
  - \( Q = \{ q_0, q_1, q_2, q_3 \} \)
  - \( \Sigma = \{ a, b \} \)
  - \( F = \{ q_0 \} \) (el √∫nico estado de aceptaci√≥n)

- **Carrera de ejemplo sobre la palabra `aabb`:**

  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{b} q_3 \xrightarrow{b} q_0
  \]

  Aqu√≠, la palabra **s√≠ se acepta**, porque termina en \( q_0 \), que es estado final.

- **Estado trampa:**  
  Tambi√©n se menciona un DFA con un estado trampa, que es un estado del que no se puede salir.  
  Una vez que entras all√≠, la palabra queda autom√°ticamente rechazada.  
  Aunque existe, a veces no se dibuja en los diagramas por simplicidad.

## 1.3.2 DFAs como estructuras de datos

Los **Aut√≥matas Finitos Deterministas (DFAs)** son modelos matem√°ticos utilizados para representar sistemas capaces de reconocer patrones en cadenas de s√≠mbolos. Aunque provienen de la teor√≠a de lenguajes formales, tambi√©n se consideran **estructuras de datos**, ya que almacenan informaci√≥n de forma organizada para procesar entradas paso a paso siguiendo reglas definidas.

Desde una perspectiva computacional, un DFA es una **estructura compuesta por elementos finitos y relaciones internas**, dise√±ada para describir comportamientos secuenciales.

---

## Componentes fundamentales de un DFA

### ‚úî 1. Estados  
Un DFA contiene un conjunto finito de **estados**, cada uno representando una situaci√≥n del sistema.  
Como estructura de datos, los estados funcionan como **nodos etiquetados** que permiten recordar:

- qu√© s√≠mbolos se han procesado,
- en qu√© condici√≥n se encuentra la m√°quina.

---

### ‚úî 2. Alfabeto  
El alfabeto es el conjunto finito de s√≠mbolos v√°lidos como entrada.  
Act√∫a como un dominio de valores permitido, limitando la complejidad del procesamiento.

---

### ‚úî 3. Estado inicial  
Es el punto de partida de la m√°quina.  
Desde la perspectiva de estructura de datos, equivale a un **nodo ra√≠z** o a una variable inicializada.

---

### ‚úî 4. Estados de aceptaci√≥n  
Son estados marcados como "v√°lidos".  
Determinan si la cadena procesada es **aceptada** o **rechazada** al finalizar.

---

### ‚úî 5. Funci√≥n de transici√≥n  
La funci√≥n de transici√≥n especifica:

> ‚ÄúSi estoy en el estado X y leo el s√≠mbolo Y, voy al estado Z‚Äù.

Como estructura de datos puede representarse mediante:

- tablas,
- grafos dirigidos,
- diccionarios (clave ‚Üí valor),
- listas de adyacencia.

Es el mecanismo que almacena las reglas de movimiento.


# 1.3.2.1 Por qu√© un DFA es una estructura de datos

### üîπ 1. Almacenamiento organizado  
Un DFA guarda:

- estados,
- s√≠mbolos,
- transiciones,
- estados finales.

Todo su dise√±o es estructural: define c√≥mo se organiza y consulta la informaci√≥n.


### üîπ 2. Operaciones definidas  
La operaci√≥n principal del DFA es:

> Procesar una cadena s√≠mbolo por s√≠mbolo.

Equivale a recorrer:

- un grafo,
- una tabla,
- un mapa de transiciones.


### üîπ 3. Acceso eficiente  
Cada transici√≥n se ejecuta en **O(1)**:  
para cada par *(estado, s√≠mbolo)* hay un √∫nico destino.

Esto los hace ideales para:

- analizadores l√©xicos,
- validadores,
- reconocimiento r√°pido de patrones.


### üîπ 4. M√∫ltiples representaciones internas  
Un DFA puede almacenarse como:

- matriz de transici√≥n,
- tabla hash,
- lista de adyacencia,
- json/yaml,
- clases de programaci√≥n (Java, Python, etc.).

Esto evidencia que tambi√©n es una **estructura de datos**.


# 1.3.2.2 Interpretaci√≥n computacional

Desde el punto de vista computacional, un DFA es una **m√°quina que interpreta datos** mediante una estructura fija.

La m√°quina:

1. Recibe s√≠mbolos.
2. Recorre su estructura interna (estados y transiciones).
3. Mantiene solo una memoria finita (el estado actual).
4. Produce una salida binaria: *Aceptar* o *Rechazar*.


## 1.3.3 Aut√≥matas Finitos No Deterministas (AFND)

Hasta ahora hemos trabajado con Aut√≥matas Finitos Deterministas (AFD), donde las reglas son estrictas: para cada estado y cada s√≠mbolo existe un √∫nico camino a seguir. Sin embargo, los lenguajes m√°s complejos suelen requerir mayor flexibilidad. Aqu√≠ es donde aparece el no determinismo.

Los Aut√≥matas Finitos No Deterministas (AFND), tambi√©n conocidos simplemente como aut√≥matas no deterministas, introducen la posibilidad de elecci√≥n en el procesamiento de palabras. Esto simplifica notablemente la construcci√≥n de aut√≥matas para ciertos lenguajes.

#### Definici√≥n

Imagina que est√°s jugando ajedrez. Un AFD ser√≠a como un juego donde, ante cada posici√≥n del tablero, solo existe un movimiento legal posible: no hay elecci√≥n. En cambio, un Aut√≥mata Finito No Determinista (AFND) funciona como el ajedrez real: ante una misma situaci√≥n puedes tener m√∫ltiples movimientos posibles, o incluso ninguno.

Un AFND es un aut√≥mata finito que, al leer un s√≠mbolo de entrada, puede elegir el siguiente estado de entre un conjunto de estados candidatos.

Formalmente, un AFND es una tupla\
$A = (Q, \Sigma, \delta, Q_0, F)$, donde:

-   $Q$, $\Sigma$ y $F$ (estados, alfabeto y estados finales) son los mismos que en un AFD.
-   $Q_0$ es un conjunto no vac√≠o de estados iniciales (a diferencia del AFD, que tiene solo uno).
-   $\delta : Q \times \Sigma \to \mathcal{P}(Q)$ es la relaci√≥n de transici√≥n, que devuelve un conjunto de posibles estados siguientes.

### Ventajas sobre el AFD

El dise√±o de un AFND suele ser m√°s directo e intuitivo que el de un AFD. En un AFND no estamos obligados a definir qu√© ocurre con cada s√≠mbolo en cada estado. Si un camino no lleva a ninguna parte, simplemente "muere" sin afectar a los dem√°s recorridos. Esto nos permite modelar patrones sin preocuparnos por todas las combinaciones de errores que un AFD obligar√≠a a representar.

#### Diferencias clave con un AFD

La diferencia principal radica en el concepto de recorrido:

| Caracter√≠stica | AFD (Determinista) | AFND (No Determinista) |
|------------------------|------------------------|------------------------|
| Siguiente estado | Totalmente determinado por el estado actual y el s√≠mbolo le√≠do. | Puede elegir entre varios estados posibles. |
| Recorridos por palabra | Exactamente uno. | Puede haber cero, uno o muchos. |
| Estado inicial | Uno solo ($q_0$). | Conjunto no vac√≠o de estados iniciales ($Q_0$). |

#### C√≥mo funcionan las transiciones no deterministas

Para entenderlo, comparemos ambos modelos:

-   En un AFD, si estamos en el estado $q$ y leemos el s√≠mbolo $a$, el siguiente estado $q'$ es √∫nico:\
    $q' = \delta(q, a)$.
-   En un AFND, al estar en $q$ y leer $a$, la funci√≥n $\delta(q, a)$ devuelve un conjunto de estados posibles.\
    El aut√≥mata puede moverse a cualquiera de ellos.\
    Si $\delta(q, a) = \emptyset$, no existe un camino a seguir desde $q$ con la entrada $a$.

Un recorrido (run) de un AFND sobre una entrada $a_0 a_1 \cdots a_n$ es una secuencia\
$p_0, p_1, \ldots, p_n$ tal que:

-   $p_0 \in Q_0$
-   $p_{i+1} \in \delta(p_i, a_i)$

#### Ventajas y usos

Los AFND no aumentan el poder expresivo respecto a los AFD (reconocen los mismos lenguajes regulares), pero ofrecen ventajas importantes:

-   **Facilidad de dise√±o:** construir un AFND suele ser m√°s sencillo.
-   **Representaci√≥n natural de operaciones:** la uni√≥n de lenguajes se representa f√°cilmente mediante bifurcaci√≥n en un AFND.
-   **Aplicaciones algor√≠tmicas:** son la base para algoritmos de b√∫squeda de patrones, donde se construye un AFND a partir de una expresi√≥n regular.

#### Lenguaje reconocido

La aceptaci√≥n en un AFND es **existencial**:

Una palabra $w$ es aceptada si **al menos uno** de los posibles recorridos termina en un estado final.\
Es decir, existe un recorrido $p_0, p_1, \ldots, p_n$ tal que $p_n \in F$.

Si hay varios estados iniciales, el lenguaje reconocido es la **uni√≥n** de los lenguajes aceptados desde cada estado inicial.

En resumen: $$
L(A) = \{\, w \in \Sigma^* : w \text{ es aceptada por } A \,\}.
$$

------------------------------------------------------------------------

## 1.3.4 Aut√≥matas Finitos No Deterministas con $\epsilon$-Transiciones ($\epsilon$-AFND)

Si el AFND nos dio libertad para elegir caminos, el $\epsilon$-AFND a√±ade un ‚Äúsuperpoder‚Äù: la capacidad de moverse sin consumir ning√∫n s√≠mbolo de entrada.

Un AFND con $\epsilon$-transiciones es un aut√≥mata que permite movimientos espont√°neos, sin leer letras del alfabeto.

#### ¬øQu√© son las transiciones √©psilon?

Las $\epsilon$-transiciones son movimientos internos que el aut√≥mata puede realizar sin consumir un s√≠mbolo. Estas transiciones est√°n etiquetadas con la palabra vac√≠a $\epsilon$.

#### C√≥mo funcionan y por qu√© son importantes

Un AFND est√°ndar solo puede cambiar de estado al leer una letra del alfabeto. Un $\epsilon$-AFND puede cambiar de estado al leer una letra o al ejecutar una $\epsilon$-transici√≥n.

Un AFND solo puede cambiar de estado al leer un s√≠mbolo del alfabeto.\
Un $\epsilon$-AFND puede cambiar de estado:

-   al leer un s√≠mbolo, o ejecutando una transici√≥n $\epsilon$.

La relaci√≥n de transici√≥n se extiende: $$
\delta : Q \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q).
$$

Una palabra $a_1 a_2 \cdots a_n$ es aceptada si existe un recorrido que consume exactamente esa palabra, permitiendo cualquier n√∫mero de transiciones $\epsilon$ antes, entre o despu√©s de los s√≠mbolos.

Estas transiciones son esenciales en algoritmos de conversi√≥n, por ejemplo, al traducir expresiones regulares a aut√≥matas.

#### Diferencias entre AFND y $\epsilon$-AFND

La diferencia est√° en la relaci√≥n de transici√≥n:

-   En el AFND, solo hay transiciones con s√≠mbolos de $\Sigma$.\
-   En el $\epsilon$-AFND, tambi√©n puede haber transiciones etiquetadas con $\epsilon$.

### Analog√≠a constructiva: ‚ÄúEl edificio y los andamios‚Äù

Construir un AFD es como levantar un edificio colocando ladrillos definitivos desde el inicio.\
Construir un $\epsilon$-AFND es como usar andamios: las transiciones $\epsilon$ permiten unir partes del aut√≥mata de forma modular y flexible.

### Explicaci√≥n de la $\epsilon$-cerradura (epsilon-closure)

La $\epsilon$-cerradura de un estado $q$ es el conjunto de todos los estados accesibles desde $q$ usando √∫nicamente transiciones $\epsilon$.

Este concepto es crucial para eliminar $\epsilon$-transiciones y convertir un $\epsilon$-AFND en un AFND est√°ndar.


