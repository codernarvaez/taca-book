---
title: "Capitulo 2"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---


# 2.1 DFAs minimales (introducción)

## Motivación

- Un **DFA** (autómata finito determinista) puede reconocer un lenguaje usando más estados de los necesarios.
- Un **DFA minimal** es aquel que:
  - reconoce el mismo lenguaje que cualquier otro DFA equivalente, y  
  - tiene el **menor número posible de estados**.
- Todo lenguaje regular tiene un DFA minimal, y este es **único salvo renombrar estados**  
  (es decir, todos los DFAs minimales para un mismo lenguaje son isomorfos).

---

## Lenguajes residuales

Sea \(L \subseteq \Sigma^{*}\) un lenguaje y \(w \in \Sigma^{*}\) una palabra.

- El **residual de \(L\) respecto a \(w\)** (también llamado *cociente izquierdo*) es:
  \[
  L_w = \{\, u \in \Sigma^{*} \mid wu \in L \,\}.
  \]

**Intuición:**  
\(L_w\) contiene todos los sufijos que, pegados detrás de \(w\), dan una palabra de \(L\).

**Propiedad clave:**

- Para todo \(u\), se cumple:
  \[
  wu \in L \quad \text{ssi} \quad u \in L_w.
  \]
- El residual \(L_w\) es el **único** lenguaje que cumple esa propiedad para la palabra \(w\).

---

### Ejemplo 1: lenguaje finito

Sea \(\Sigma = \{a,b\}\) y \(L = \{a,ab,ba,aab\}\).

Algunos residuales:

- \(L_{\varepsilon} = L = \{a,ab,ba,aab\}\).
- \(L_{a} = \{\varepsilon, b, ab\}\)  
  (son los sufijos que, pegados tras una \(a\), dan palabras de \(L\)).
- \(L_{b} = \{a\}\).
- \(L_{aa} = \{b\}\).
- \(L_{ab} = \{\varepsilon\}\).
- \(L_{ba} = \{\varepsilon\}\).
- \(L_{bb} = \varnothing\).

A partir de cierta longitud, casi todos los residuales son \(\varnothing\), salvo el correspondiente a \(aab\), cuyo residual es \(\{\varepsilon\}\).

En total, este lenguaje tiene **seis residuales distintos**:
\[
L,\ \{\varepsilon, b, ab\},\ \{a\},\ \{b\},\ \{\varepsilon\},\ \varnothing.
\]

---

### Ejemplo 2: lenguaje con una sola clase residual

Para el lenguaje \(L = (a+b)^{*}\) (todas las palabras sobre \(\{a,b\}\)):

- Para cualquier \(w\), el residual \(L_w\) vuelve a ser todo \((a+b)^{*}\).
- Solo hay **un residual** distinto.

---

### Ejemplo 3: paridad de letras

Sea \(L\) el conjunto de palabras con **número par de \(a\)** y **número par de \(b\)**.

- Hay cuatro residuales, según la paridad de cada letra:
  - \(EE\): par en \(a\) y par en \(b\).
  - \(EO\): par en \(a\) e impar en \(b\).
  - \(OE\): impar en \(a\) y par en \(b\).
  - \(OO\): impar en \(a\) e impar en \(b\).

Cada residual corresponde a una combinación de paridades; al leer una \(a\) o una \(b\), se cambia de residual según se altere la paridad de esa letra.  
Esos cuatro residuales forman el DFA minimal de este lenguaje.

---

### Ejemplo 4: lenguajes con infinitos residuales

Hay lenguajes (no regulares) cuyo número de residuales es **infinito**, por ejemplo:

- \(L_1 = \{ a^{n} b^{n} : n \ge 0 \}\).
- \(L_2 = \{ ww : w \in \{0,1\}^{*} \}\).

En ambos casos se puede construir una familia infinita de palabras \(w_0, w_1, \dots\) tal que sus residuales \(L_{w_i}\) son todos distintos.  

Esta es una de las ideas detrás del **teorema de Myhill–Nerode**:  
los lenguajes con infinitos residuales no son regulares.

---

## Estados de un DFA y residuales

Sea \(A = (Q, \Sigma, \delta, q_0, F)\) un autómata **determinista** (no necesariamente finito en esta sección).

- Para cada estado \(q \in Q\), definimos el **lenguaje reconocido desde \(q\)**:
  \[
  L(q) = \{\, w \in \Sigma^{*} \mid A \text{ acepta } w \text{ empezando en } q \,\}.
  \]
- Si hay una transición \(q \xrightarrow{a} q'\), entonces:
  \[
  L(q') = \{ u \mid au \in L(q) \} = L(q)_a.
  \]

Suponiendo que \(A\) reconoce el lenguaje \(L = L(q_0)\), se cumple:

::: {.callout-note}
### Lema importante

- (a) Para toda palabra \(w\), si \(q_w\) es el estado alcanzado desde \(q_0\) al leer \(w\), entonces  
  \[
  L(q_w) = L_w.
  \]
  Es decir, **todo residual** \(L_w\) de \(L\) es reconocido desde algún estado del DFA.
- (b) Para cada estado \(q\) alcanzable desde \(q_0\), hay al menos una palabra \(w\) tal que \(L(q) = L_w\).
:::

**Conclusión:**  
Los estados alcanzables de cualquier DFA que reconoce \(L\) corresponden a residuales del lenguaje.  
Distintos estados pueden corresponder al mismo residual si el DFA no es minimal.

---

## Autómata determinista canónico

A partir de los residuales se construye el **autómata canónico** de \(L\).

### Definición (autómata canónico \(C_L\))

Para un lenguaje \(L \subseteq \Sigma^{*}\), definimos:

- Conjunto de estados:
  \[
  Q_L = \{ L_w : w \in \Sigma^{*} \}
  \]
  (el conjunto de **todos los residuales** de \(L\)).
- Alfabeto: \(\Sigma\).
- Transición:
  \[
  \delta_L(L_w, a) = L_{wa}.
  \]
- Estado inicial: \(q_0^L = L\) (el residual de la palabra vacía \(\varepsilon\)).
- Estados de aceptación:
  \[
  F_L = \{ L_w \in Q_L : \varepsilon \in L_w \}.
  \]

En este autómata, **cada estado “reconoce su propio lenguaje”**:  
el lenguaje aceptado al empezar en el estado \(L_w\) es precisamente \(L_w\).

---

### Propiedades del autómata canónico

1. \(C_L\) reconoce exactamente el lenguaje \(L\).

2. Si \(L\) es regular, entonces:
   - El número de estados de \(C_L\) es igual al número de residuales distintos de \(L\).
   - Cualquier DFA que reconozca \(L\) tiene **al menos** tantos estados como \(C_L\).
   - Por tanto, \(C_L\) es un **DFA minimal**.

3. **Unicidad:**  
   Si \(A\) es otro DFA minimal que reconoce \(L\), sus estados se pueden emparejar uno a uno con los de \(C_L\) preservando:
   - las transiciones,
   - el estado inicial,
   - y los estados de aceptación.

   Es decir, \(A\) y \(C_L\) son **isomorfos**.

---

### Criterio práctico de minimalidad

::: {.callout-tip}
**Corolario:**  
Un DFA (considerando solo sus estados alcanzables) es minimal **ssi** todos sus estados reconocen lenguajes distintos.  
Es decir, si \(q \neq q'\), entonces \(L(q) \neq L(q')\).
:::

Este criterio se usa después para justificar algoritmos de minimización.

---

# 2.1.1 El Master Automaton

## Idea general

- El **master automaton** (autómata maestro) se define para un alfabeto fijo \(\Sigma\).
- Es un DFA:
  - con **infinitos estados**,
  - sin estado inicial preseleccionado,
  - donde **cada estado es un lenguaje regular** sobre \(\Sigma\).

De forma intuitiva: contiene, como sub-autómatas, **todos** los DFAs minimales de todos los lenguajes regulares sobre \(\Sigma\).

---

## Definición formal

Para un alfabeto \(\Sigma\), el **master automaton** es
\[
M = (Q_M, \Sigma, \delta_M, F_M),
\]
donde:

- \(Q_M\) es el conjunto de **todos los lenguajes regulares** sobre \(\Sigma\).
- La función de transición está dada por los residuales:
  \[
  \delta_M(L, a) = L_a
  \quad\text{para todo } L \in Q_M,\; a \in \Sigma.
  \]
- El conjunto de estados de aceptación es:
  \[
  F_M = \{\, L \in Q_M \mid \varepsilon \in L \,\}.
  \]
- No se especifica un estado inicial único; en principio podemos “empezar” en cualquier lenguaje regular \(L\).

---

## Sub-autómatas canónicos dentro del master automaton

Sea \(L\) un lenguaje regular sobre \(\Sigma\).

Consideremos el subgrafo de \(M\) formado por:

- el estado \(L\),
- todos los estados alcanzables desde \(L\) leyendo palabras de \(\Sigma^{*}\),
- y las transiciones entre esos estados.

Por la definición de \(\delta_M\) y las propiedades de los residuales:

- Ese subgrafo es **exactamente el DFA canónico \(C_L\)** del lenguaje \(L\).
- Así, el master automaton **“contiene” todos los DFAs minimales** como sub-autómatas alcanzables.

---

## Ejemplo sobre \(\Sigma = \{a, b\}\)

Para el alfabeto \(\{a,b\}\), el master automaton incluye estados como:

- \(\varnothing\),
- \(\Sigma^{*}\),
- \(\Sigma \Sigma^{*}\) (todas las palabras de longitud al menos 1),
- \(\varepsilon + \Sigma^{2}\Sigma^{*}\) (o bien la palabra vacía, o bien palabras de longitud al menos 2),
- muchos otros lenguajes definidos por expresiones regulares.

Las aristas etiquetadas con \(a\) o \(b\) conectan estos estados según el residual correspondiente.  
Cada DFA minimal que conozcas sobre \(\{a,b\}\) aparece dentro de este master automaton como el subgrafo alcanzable desde el estado que representa su lenguaje.


# 2.2 Minimización DFAs

Cuando diseñamos un **Autómata Finito Determinista (DFA)**, a menudo terminamos con una máquina que tiene más "piezas" (estados) de las necesarias. Funciona bien, pero es redundante.

El proceso de **minimización** consiste en transformar ese autómata en su versión más eficiente posible. El objetivo es obtener un autómata único que haga exactamente el mismo trabajo (reconocer el mismo lenguaje) pero utilizando la menor cantidad de estados posibles.

### La Estrategia General

Para lograr esto, no eliminamos estados al azar. Seguimos un algoritmo lógico que consta de dos grandes fases:

1.  **Agrupar (La Partición):** Identificamos qué estados son "equivalentes" entre sí. Si dos estados se comportan exactamente igual ante cualquier entrada, no necesitamos tenerlos por separado; pueden considerarse gemelos.
2.  **Fusionar:** Una vez identificados los grupos de gemelos, los fusionamos en un solo estado representativo.

A continuación, explicamos en detalle la primera fase, que es el corazón del procedimiento.

---

## 2.2.1 Computing the Language Partition

La clave para minimizar es descubrir qué estados son indistinguibles. Para ello, utilizamos el concepto de **partición**.

Imagina una partición como una forma de clasificar todos los estados del autómata en diferentes "cajas" o bloques.
* Cada estado debe estar en una sola caja.
* No puede sobrar ningún estado.

El objetivo del algoritmo es refinar estas cajas progresivamente: empezamos con cajas muy grandes y las vamos dividiendo (haciendo más específicas) hasta que todos los estados dentro de una misma caja sean verdaderamente equivalentes.

### Paso 1: La División Inicial (El Presente)

La primera distinción es la más obvia y se basa en lo que los estados "son" en este momento. Dividimos todo el autómata en dos grupos fundamentales:

* **Grupo de Aceptación (Finales):** Aquí van todos los estados que dicen "Sí" (aceptan la cadena).
* **Grupo de No Aceptación (No Finales):** Aquí van todos los estados que no aceptan.

**¿Por qué hacemos esto?** Porque un estado que acepta nunca puede ser equivalente a uno que no acepta. Es la diferencia fundamental.

### Paso 2: El Refinamiento (Mirando al Futuro)

Una vez que tenemos la división inicial, debemos comprobar si los estados dentro de un mismo grupo realmente merecen seguir juntos. Para ello, miramos cómo reaccionan ante las entradas (las letras del alfabeto del autómata).

**La Regla de la Separación:**
Dos estados, llamémoslos **A** y **B**, pueden permanecer en el mismo grupo solo si, al recibir la misma letra, ambos viajan a destinos que también están en el mismo grupo.

Si **A** viaja a un grupo "X" y **B** viaja a un grupo "Y" (y "X" e "Y" son grupos distintos), entonces **A** y **B** tienen destinos diferentes. Esto significa que **A** y **B** no se comportan igual y deben separarse.

#### ¿Cómo funciona el proceso de división ("Splitting")?

El algoritmo busca "inestabilidad" en los grupos. Un grupo es inestable si contiene estados que quieren ir a sitios distintos.

1.  Tomamos un grupo actual y una letra del alfabeto (por ejemplo, la letra 'a').
2.  Observamos hacia dónde van todos los estados de ese grupo con la letra 'a'.
3.  Si todos van a destinos que pertenecen al mismo bloque, el grupo se queda como está.
4.  **Pero**, si unos van al Bloque 1 y otros van al Bloque 2, entonces nuestro grupo original se rompe en dos:
    * Subgrupo de los que van al Bloque 1.
    * Subgrupo de los que van al Bloque 2.

### El Algoritmo de Refinamiento (Paso a Paso)

Podemos resumir el algoritmo lógico ("LanPar") de la siguiente manera sencilla:

1.  **Inicio:** Crea una partición inicial con solo dos grupos: {Finales} y {No Finales}.
2.  **Ciclo de Búsqueda:** Mientras existan grupos "inestables" (grupos donde los estados reaccionan diferente ante una letra):
    * Elige un grupo y una letra que demuestren esa diferencia.
    * Divide ese grupo en subgrupos más pequeños basados en sus destinos.
3.  **Terminación (Estabilidad):** El proceso se detiene cuando ya no es posible dividir más. Esto ocurre cuando, para cualquier grupo que elijas y cualquier letra que uses, todos los estados de ese grupo siempre saltan a estados que pertenecen a un mismo bloque destino.

### Resultado Final

Al terminar, obtenemos la **Partición Estable**. Cada bloque de esta partición contiene estados que son matemáticamente equivalentes.
* Reconocen exactamente el mismo "futuro" del lenguaje.
* Si intercambiaras uno por otro, el autómata seguiría funcionando igual.

Esta partición es la receta perfecta para construir el autómata minimizado: cada bloque se convertirá en un único estado en la nueva versión reducida de la máquina.

## 2.2.2 Quotienting en Autómatas Finitos Deterministas (DFA)

### ¿Qué es Quotienting?

**Quotienting** (o cociente) es una técnica fundamental en teoría de autómatas que nos permite **minimizar** un autómata finito determinista (DFA). El objetivo es crear el DFA más pequeño posible que reconozca exactamente el mismo lenguaje que el original.

### ¿Por qué es importante?

Imagina que tienes un DFA con 100 estados, pero en realidad podrías tener uno equivalente con solo 20 estados. El DFA minimizado:
- Usa menos memoria
- Es más eficiente computacionalmente
- Es más fácil de entender y analizar

### Conceptos Clave

#### Estados Equivalentes

Dos estados son **equivalentes** si, sin importar qué cadena de entrada reciban a partir de ese punto, ambos llevan al autómata a aceptar o rechazar de la misma manera.

**Ejemplo intuitivo:** Imagina dos puertas en un laberinto. Si desde ambas puertas puedes llegar exactamente a los mismos lugares siguiendo los mismos caminos, entonces esas puertas son "equivalentes" y podrías reemplazarlas por una sola.

#### Clases de Equivalencia

Una **clase de equivalencia** es un conjunto de estados que son todos equivalentes entre sí. Cuando hacemos quotienting, cada clase de equivalencia se convierte en un único estado en el DFA minimizado.

### El Proceso de Quotienting

#### Paso 1: Identificar Estados Distinguibles

Dos estados son **distinguibles** si existe una cadena que, empezando desde uno, lleva a aceptar, pero empezando desde el otro, lleva a rechazar.

#### Paso 2: Construir la Tabla de Distinguibilidad

Creamos una tabla donde marcamos qué pares de estados son distinguibles:
1. **Inicialización:** Marcamos como distinguibles todos los pares (estado final, estado no final)
2. **Iteración:** Si desde dos estados, con el mismo símbolo, llegamos a estados ya distinguibles, entonces esos dos estados también son distinguibles
3. **Repetimos** hasta que no haya cambios

#### Paso 3: Agrupar Estados Equivalentes

Los estados que NO son distinguibles forman una clase de equivalencia.

#### Paso 4: Construir el DFA Minimizado

Cada clase de equivalencia se convierte en un estado del nuevo DFA.

---

## Ejemplo Completo

### DFA Original

Consideremos un DFA que acepta cadenas sobre el alfabeto {0, 1} donde el número de 1's es par.

**Estados:** {q0, q1, q2, q3, q4}
- q0: estado inicial (número par de 1's visto)
- q1: número impar de 1's visto
- q2: estado "trampa" redundante (par de 1's)
- q3: estado redundante (impar de 1's)
- q4: otro estado redundante (par de 1's)

**Estados finales:** {q0, q2, q4} (todos representan número par de 1's)

**Transiciones:**

| Estado | 0 | 1 |
|--------|---|---|
| q0 | q0 | q1 |
| q1 | q1 | q0 |
| q2 | q2 | q3 |
| q3 | q3 | q2 |
| q4 | q4 | q1 |

#### Tabla de Distinguibilidad

Construimos una tabla triangular para todos los pares de estados:

**Iteración 0:** Marcamos pares (final, no-final)

```
     q0   q1   q2   q3   q4
q1   X
q2   -
q3   X    -
q4   -    X    -
```

Leyenda:
- `X` = distinguibles (uno es final, otro no)
- `-` = posiblemente equivalentes (ambos finales o ambos no-finales)

**Iteración 1:** Revisamos transiciones

Para cada par no marcado (p, q):
- Si δ(p, a) y δ(q, a) están marcados como distinguibles → marcamos (p, q)

Comprobamos:
- (q0, q2): δ(q0, 0)=q0, δ(q2, 0)=q2 → revisar (q0, q2) [no marcado]
  - δ(q0, 1)=q1, δ(q2, 1)=q3 → (q1, q3) [no marcado aún]
- (q0, q4): δ(q0, 1)=q1, δ(q4, 1)=q1 → mismo destino ✓
  - δ(q0, 0)=q0, δ(q4, 0)=q4 → revisar (q0, q4)
- (q2, q4): δ(q2, 1)=q3, δ(q4, 1)=q1 → (q3, q1) está marcado X

```
     q0   q1   q2   q3   q4
q1   X
q2   -
q3   X    -
q4   -    X    X
```

**Iteración 2:** Propagamos

Revisando (q0, q2) nuevamente:
- Sus transiciones con 1 van a (q1, q3), que no están marcados
- Ninguna evidencia de distinguibilidad aún

Continuamos hasta que no haya cambios. Después de completar:

```
     q0   q1   q2   q3   q4
q1   X
q2   -         (equivalente a q0)
q3   X    -    (equivalente a q1)
q4   -    X    -    X   (equivalente a q0)
```

#### Clases de Equivalencia (Cocientes)

De la tabla obtenemos:
- **[q0] = {q0, q2, q4}** - estados con número par de 1's
- **[q1] = {q1, q3}** - estados con número impar de 1's

#### DFA Minimizado

**Estados:** {[q0], [q1]}
- [q0]: estado inicial y final
- [q1]: estado no final

**Transiciones:**

| Estado | 0 | 1 |
|--------|---|---|
| [q0] | [q0] | [q1] |
| [q1] | [q1] | [q0] |

**Resultado:** Hemos reducido de 5 estados a solo 2 estados, manteniendo el mismo lenguaje.

---
