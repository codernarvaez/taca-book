title: "Propiedades y Operaciones de Lenguajes Regulares"
author: "Marylin Alvarado"
format: html
toc: true
---

## 5. Propiedades y Operaciones de Lenguajes Regulares

Aquí se analizan las características inherentes de la familia de lenguajes regulares, demostrando cómo se pueden combinar y optimizar.
***

### 5.1 Propiedades de Clausura de Lenguajes Regulares

Las **propiedades de clausura** de los lenguajes regulares establecen que si tomamos uno o más lenguajes regulares y aplicamos una operación específica (como unión, concatenación o intersección), el lenguaje resultante también será un lenguaje regular. Los Autómatas Finitos Deterministas (**AFD**) son fundamentales para demostrar estas propiedades mediante la construcción de nuevos autómatas.

#### Concepto de Clausura con AFDs

La demostración de la clausura se realiza construyendo un nuevo AFD, $A_{nuevo}$, a partir de los AFDs originales, $A_1$ y $A_2$, de tal manera que $L(A_{nuevo})$ sea el resultado de la operación aplicada a $L(A_1)$ y $L(A_2)$. Esta construcción se conoce comúnmente como la **Construcción Producto**.

#### Unión ($\cup$)

* **Operación:** $L(A_1) \cup L(A_2)$
* **Demostración con AFDs (Construcción Producto):**
    * Se construye un nuevo AFD cuyos estados son **pares ordenados** $(q_1, q_2)$, donde $q_1$ es un estado de $A_1$ y $q_2$ es un estado de $A_2$.
    * Un estado $(q_1, q_2)$ es un **estado final** en el nuevo AFD si al menos uno de los estados originales es final, es decir, si $q_1 \in F_1$ **o** $q_2 \in F_2$.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **unión**.

#### Concatenación ($\cdot$)

* **Operación:** $L(A_1) \cdot L(A_2)$
* **Demostración con AFDs:** Aunque se puede demostrar con AFDs, es más complejo que en AFNDs. En la práctica, se utiliza el hecho de que los AFNDs son equivalentes a los AFDs. La demostración mediante AFNDs ($\epsilon$-transiciones) es más sencilla y directa.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **concatenación**.

#### Intersección ($\cap$)

* **Operación:** $L(A_1) \cap L(A_2)$
* **Demostración con AFDs (Construcción Producto):** Se utiliza la misma **construcción producto** de estados $(q_1, q_2)$.
    * Un estado $(q_1, q_2)$ es un **estado final** en el nuevo AFD si **ambos** estados originales son finales, es decir, si $q_1 \in F_1$ **y** $q_2 \in F_2$.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **intersección**.

***

### 5.2 Operaciones de Clausura en NFAs

La demostración de las propiedades de clausura para los lenguajes regulares (Unión, Concatenación y Clausura de Kleene) es más sencilla y elegante utilizando **Autómatas Finitos No Deterministas (AFND)**, especialmente con el uso de las $\epsilon$-transiciones. La flexibilidad del no-determinismo permite "unir" los autómatas de manera eficiente sin explosionar el número de estados de forma inmediata.

#### Clausura de Kleene (Estrella) ($\star$)

* **Definición:** $L^{\star} = L^0 \cup L^1 \cup L^2 \cup \dots$
* **Demostración con AFNDs:**
    1.  Se añade un **nuevo estado inicial/final** $q_{nuevo}$.
    2.  Se añade una **$\epsilon$-transición** desde $q_{nuevo}$ al antiguo estado inicial de $A$ (para comenzar la primera iteración o la única).
    3.  Se añaden **$\epsilon$-transiciones** desde cada estado final de $A$ de vuelta a $q_{nuevo}$ (o al antiguo estado inicial de $A$) para permitir la repetición (la estrella).
    4.  El estado $q_{nuevo}$ acepta $\epsilon$ (la cadena vacía), que es parte de $L^0$.
* **Ventaja sobre AFDs:** Un AFD requeriría un mecanismo mucho más complejo (y a menudo más grande) para manejar los puntos de repetición y la posible vuelta al estado inicial después de cada aceptación.

#### Concatenación ($\cdot$)

* **Definición:** $L(A_1) \cdot L(A_2)$
* **Demostración con AFNDs:**
    1.  Se mantiene el estado inicial de $A_1$ como el nuevo estado inicial.
    2.  Se añaden **$\epsilon$-transiciones** desde todos los estados finales de $A_1$ hacia el estado inicial de $A_2$.
    3.  Los estados finales de $A_1$ dejan de ser finales.
    4.  Los estados finales de $A_2$ se convierten en los nuevos estados finales.
* **Ventaja sobre AFDs:** El AFND simplemente "conecta" el final del primer autómata con el inicio del segundo sin la necesidad de construir un producto que simule todas las combinaciones posibles de estados intermedios.

***

### 5.3 Algoritmos de Minimización de AFDs

La minimización de un AFD busca encontrar el **AFD mínimo**, que es un AFD equivalente al original, pero con el menor número posible de estados.

#### Concepto de Estados Equivalentes e Indistinguibles

La minimización se fundamenta en la capacidad de identificar y fusionar estados que tienen el mismo comportamiento de aceptación:

* **Estados Indistinguibles (Equivalentes):** Dos estados $p$ y $q$ de un AFD, $A$, son **indistinguibles** si, para *cualquier* palabra $w$ que se les suministre, o bien ambos terminan en un estado final, o bien ambos terminan en un estado no final. En otras palabras, aceptan exactamente el mismo conjunto de sufijos: $L_A(p) = L_A(q)$.
* **Estados Distinguibles:** Dos estados $p$ y $q$ son **distinguibles** si existe al menos una palabra $w$ (la **cadena distinguible**) tal que la lectura de $w$ desde $p$ conduce a un estado final y la lectura de $w$ desde $q$ conduce a un estado no final, o viceversa.

#### Algoritmo de Llenado de Tabla (*Table-Filling Algorithm*)

Este es un enfoque sistemático para encontrar todos los pares de estados distinguibles:

1.  **Paso Base:** Marcar como distinguibles todos los pares $(p, q)$ donde $p$ es final y $q$ no es final (porque $\epsilon$ es una cadena distinguible).
2.  **Paso Inductivo:** Iterar. Un par $(p, q)$ se marca como distinguible si, para algún símbolo de entrada $a$, el par de estados de destino $(\delta(p, a), \delta(q, a))$ ya ha sido previamente marcado como distinguible.
3.  **Resultado:** Cuando no se pueden hacer más marcas, los pares de estados que quedan sin marcar son los indistinguibles y deben fusionarse en un único estado en el AFD mínimo.

#### Algoritmo de Hopcroft

Este algoritmo es un método de partición que es más eficiente para grandes autómatas, con una complejidad de tiempo de $O(n \log n)$.

1.  **Inicialización:** Se crea una partición inicial $P$ de los estados en dos grupos: $F$ (estados finales) y $Q - F$ (estados no finales).
2.  **Refinamiento:** Iterar hasta que la partición $P$ no cambie. En cada paso, se refina la partición tomando un bloque $B$ de $P$ y un símbolo $a$, y se divide $B$ en sub-bloques basados en el bloque al que se llega con $a$. Si los estados en $B$ tienen transiciones con $a$ que llegan a diferentes bloques de la partición actual, entonces $B$ debe ser dividido.
3.  **Resultado:** Los bloques de la partición final representan los estados del AFD mínimo. Se construye el autómata mínimo (el autómata cociente) tomando estos bloques como sus estados.

Ambos algoritmos conducen al mismo **AFD Mínimo Único** (salvo por el nombre de los estados).
## 5.4 Contexto de Clausura de Lenguajes Regulares

Los lenguajes regulares (LR) son la clase más simple de lenguajes formales, situados en el Tipo 3 de la Jerarquía de Chomsky. Una característica definitoria de los LR es su robustez bajo operaciones fundamentales, conocidas como propiedades de clausura.

Los lenguajes regulares son cerrados bajo las siguientes operaciones, lo que significa que aplicar cualquiera de ellas a uno o dos LR siempre resulta en otro LR:

- Unión: L1 ∪ L2
- Concatenación: L1 · L2
- Clausura de Kleene: L*
- Intersección: L1 ∩ L2
- Complemento: Lᶜ
- Reversa: LR

Estas propiedades se demuestran mediante construcciones algorítmicas que, dado un autómata que acepta el lenguaje de entrada, generan un nuevo autómata que acepta el lenguaje resultante de la operación.

### 5.4.1 Operaciones de Clausura y la Ventaja Estructural del AFND-ε

Aunque los modelos AFD, AFND y AFND-ε son computacionalmente equivalentes (es decir, reconocen la misma clase de lenguajes), su simplicidad constructiva varía notablemente según la operación que se intente modelar.

El AFND-ε es la estructura más elemental para el diseño inicial de autómatas, ya que impone menos restricciones en su función de transición. Esta flexibilidad permite que las construcciones basadas en expresiones regulares sean inductivas y modulares: los autómatas de expresiones complejas se construyen "pegando" o "envolviendo" autómatas más simples.

La parte I del Teorema de Kleene establece que para toda expresión regular R se puede construir un AFND-ε M tal que L(M) = L(R). Este proceso constructivo revela la superioridad práctica del AFND-ε para operaciones como la concatenación y la clausura, por su sencillez y modularidad.

### 5.4.2 La Concatenación de Lenguajes (R · S)

Dado dos lenguajes regulares R y S, reconocidos por autómatas M1 y M2 respectivamente, la concatenación R · S es el lenguaje formado por todas las palabras que resultan de tomar una palabra de R seguida inmediatamente por una palabra de S.

Implementación en AFND-ε (Modularidad en serie):

1. Se toma el AFND-ε M1 que acepta R y el AFND-ε M2 que acepta S.
2. Se crea un nuevo autómata que conecta M1 y M2 en serie.
3. Se añade una transición ε desde el (único) estado final de M1 hasta el estado inicial de M2.
4. El nuevo autómata utiliza como estado inicial al de M1 y como estado final al de M2.

La transición ε permite pasar del final de la cadena de R al inicio de la cadena de S sin consumir símbolos, lo que facilita una construcción modular y local.

### 5.4.3 La Clausura de Kleene (R*)

La clausura de Kleene R* representa el conjunto de cadenas formadas por cero o más repeticiones de palabras en R.

Implementación en AFND-ε (Estructura de bucle):

Partiendo de un autómata M que reconoce R:

1. Se introduce un nuevo estado inicial q0 y un nuevo estado final qf.
2. Se añade una transición ε de q0 al estado inicial original de M.
3. Se añaden transiciones ε desde los estados finales de M hacia el estado inicial original, permitiendo repetir cadenas.
4. Se añade una transición ε de q0 a qf para aceptar la cadena vacía (ε).

Las transiciones ε facilitan la repetición indefinida y la aceptación de la cadena vacía sin alterar el procesamiento interno del autómata.

## 5.5 Contraste con la Implementación en AFD

El motivo por el cual el AFND-ε es preferido para estas operaciones radica en la ausencia de transiciones ε en los AFD y en la restricción del determinismo.

### Desafío del determinismo en la concatenación

Un AFD exige que para cada símbolo y estado exista exactamente una transición. Esto plantea dos problemas clave al intentar modelar operaciones como la concatenación o la clausura:

1. No existen transiciones silenciosas (ε) que permitan pasar del final de R al inicio de S sin consumir símbolos.
2. En un AFD no es trivial saber, de forma determinista, en qué momento comenzar a simular el segundo autómata.

Por tanto, para simular R · S o R* en un AFD se requieren redefiniciones complejas de estados y transiciones, lo que rompe la modularidad.

### Explosión de estados

Cuando se construye un AFD equivalente mediante determinización de un AFND:

- Si el AFND tiene n estados, el AFD resultante puede tener hasta 2^n estados.

El AFND-ε permite construcciones lineales o polinomiales en muchas operaciones, mientras que exigir determinismo puede producir un crecimiento exponencial del número de estados.

### Resumen estructural

El AFND-ε actúa como una estructura composicional que traduce expresiones regulares complejas a autómatas mediante reglas locales, simples y modulares. Para la concatenación y la clausura, estas reglas requieren pocos estados y transiciones; por el contrario, la construcción equivalente en AFD es más compleja, rígida y potencialmente exponencial en tamaño.

```
