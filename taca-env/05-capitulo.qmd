---
title: "Algoritmos de Minimización de AFDs"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---

### 5.3 Algoritmos de Minimización de AFDs

La minimización de un AFD busca encontrar el **AFD mínimo**, que es un AFD equivalente al original, pero con el menor número posible de estados.

#### Concepto de Estados Equivalentes e Indistinguibles

La minimización se fundamenta en la capacidad de identificar y fusionar estados que tienen el mismo comportamiento de aceptación:

* **Estados Indistinguibles (Equivalentes):** Dos estados $p$ y $q$ de un AFD, $A$, son **indistinguibles** si, para *cualquier* palabra $w$ que se les suministre, o bien ambos terminan en un estado final, o bien ambos terminan en un estado no final. En otras palabras, aceptan exactamente el mismo conjunto de sufijos: $L_A(p) = L_A(q)$.
* **Estados Distinguibles:** Dos estados $p$ y $q$ son **distinguibles** si existe al menos una palabra $w$ (la **cadena distinguible**) tal que la lectura de $w$ desde $p$ conduce a un estado final y la lectura de $w$ desde $q$ conduce a un estado no final, o viceversa.

#### Algoritmo de Llenado de Tabla (*Table-Filling Algorithm*)

Este es un enfoque sistemático para encontrar todos los pares de estados distinguibles:

1.  **Paso Base:** Marcar como distinguibles todos los pares $(p, q)$ donde $p$ es final y $q$ no es final (porque $\epsilon$ es una cadena distinguible).
2.  **Paso Inductivo:** Iterar. Un par $(p, q)$ se marca como distinguible si, para algún símbolo de entrada $a$, el par de estados de destino $(\delta(p, a), \delta(q, a))$ ya ha sido previamente marcado como distinguible.
3.  **Resultado:** Cuando no se pueden hacer más marcas, los pares de estados que quedan sin marcar son los indistinguibles y deben fusionarse en un único estado en el AFD mínimo.

#### Algoritmo de Hopcroft

Este algoritmo es un método de partición que es más eficiente para grandes autómatas, con una complejidad de tiempo de $O(n \log n)$.

1.  **Inicialización:** Se crea una partición inicial $P$ de los estados en dos grupos: $F$ (estados finales) y $Q - F$ (estados no finales).
2.  **Refinamiento:** Iterar hasta que la partición $P$ no cambie. En cada paso, se refina la partición tomando un bloque $B$ de $P$ y un símbolo $a$, y se divide $B$ en sub-bloques basados en el bloque al que se llega con $a$. Si los estados en $B$ tienen transiciones con $a$ que llegan a diferentes bloques de la partición actual, entonces $B$ debe ser dividido.
3.  **Resultado:** Los bloques de la partición final representan los estados del AFD mínimo. Se construye el autómata mínimo (el autómata cociente) tomando estos bloques como sus estados.

Ambos algoritmos conducen al mismo **AFD Mínimo Único** (salvo por el nombre de los estados).
## 5.4 Contexto de Clausura de Lenguajes Regulares

Los lenguajes regulares (LR) son la clase más simple de lenguajes formales, situados en el Tipo 3 de la Jerarquía de Chomsky. Una característica definitoria de los LR es su robustez bajo operaciones fundamentales, conocidas como propiedades de clausura.

Los lenguajes regulares son cerrados bajo las siguientes operaciones, lo que significa que aplicar cualquiera de ellas a uno o dos LR siempre resulta en otro LR:

- Unión: L1 ∪ L2
- Concatenación: L1 · L2
- Clausura de Kleene: L*
- Intersección: L1 ∩ L2
- Complemento: Lᶜ
- Reversa: LR

Estas propiedades se demuestran mediante construcciones algorítmicas que, dado un autómata que acepta el lenguaje de entrada, generan un nuevo autómata que acepta el lenguaje resultante de la operación.

### 5.4.1 Operaciones de Clausura y la Ventaja Estructural del AFND-ε

Aunque los modelos AFD, AFND y AFND-ε son computacionalmente equivalentes (es decir, reconocen la misma clase de lenguajes), su simplicidad constructiva varía notablemente según la operación que se intente modelar.

El AFND-ε es la estructura más elemental para el diseño inicial de autómatas, ya que impone menos restricciones en su función de transición. Esta flexibilidad permite que las construcciones basadas en expresiones regulares sean inductivas y modulares: los autómatas de expresiones complejas se construyen "pegando" o "envolviendo" autómatas más simples.

La parte I del Teorema de Kleene establece que para toda expresión regular R se puede construir un AFND-ε M tal que L(M) = L(R). Este proceso constructivo revela la superioridad práctica del AFND-ε para operaciones como la concatenación y la clausura, por su sencillez y modularidad.

### 5.4.2 La Concatenación de Lenguajes (R · S)

Dado dos lenguajes regulares R y S, reconocidos por autómatas M1 y M2 respectivamente, la concatenación R · S es el lenguaje formado por todas las palabras que resultan de tomar una palabra de R seguida inmediatamente por una palabra de S.

Implementación en AFND-ε (Modularidad en serie):

1. Se toma el AFND-ε M1 que acepta R y el AFND-ε M2 que acepta S.
2. Se crea un nuevo autómata que conecta M1 y M2 en serie.
3. Se añade una transición ε desde el (único) estado final de M1 hasta el estado inicial de M2.
4. El nuevo autómata utiliza como estado inicial al de M1 y como estado final al de M2.

La transición ε permite pasar del final de la cadena de R al inicio de la cadena de S sin consumir símbolos, lo que facilita una construcción modular y local.

### 5.4.3 La Clausura de Kleene (R*)

La clausura de Kleene R* representa el conjunto de cadenas formadas por cero o más repeticiones de palabras en R.

Implementación en AFND-ε (Estructura de bucle):

Partiendo de un autómata M que reconoce R:

1. Se introduce un nuevo estado inicial q0 y un nuevo estado final qf.
2. Se añade una transición ε de q0 al estado inicial original de M.
3. Se añaden transiciones ε desde los estados finales de M hacia el estado inicial original, permitiendo repetir cadenas.
4. Se añade una transición ε de q0 a qf para aceptar la cadena vacía (ε).

Las transiciones ε facilitan la repetición indefinida y la aceptación de la cadena vacía sin alterar el procesamiento interno del autómata.

## 5.5 Contraste con la Implementación en AFD

El motivo por el cual el AFND-ε es preferido para estas operaciones radica en la ausencia de transiciones ε en los AFD y en la restricción del determinismo.

### Desafío del determinismo en la concatenación

Un AFD exige que para cada símbolo y estado exista exactamente una transición. Esto plantea dos problemas clave al intentar modelar operaciones como la concatenación o la clausura:

1. No existen transiciones silenciosas (ε) que permitan pasar del final de R al inicio de S sin consumir símbolos.
2. En un AFD no es trivial saber, de forma determinista, en qué momento comenzar a simular el segundo autómata.

Por tanto, para simular R · S o R* en un AFD se requieren redefiniciones complejas de estados y transiciones, lo que rompe la modularidad.

### Explosión de estados

Cuando se construye un AFD equivalente mediante determinización de un AFND:

- Si el AFND tiene n estados, el AFD resultante puede tener hasta 2^n estados.

El AFND-ε permite construcciones lineales o polinomiales en muchas operaciones, mientras que exigir determinismo puede producir un crecimiento exponencial del número de estados.

### Resumen estructural

El AFND-ε actúa como una estructura composicional que traduce expresiones regulares complejas a autómatas mediante reglas locales, simples y modulares. Para la concatenación y la clausura, estas reglas requieren pocos estados y transiciones; por el contrario, la construcción equivalente en AFD es más compleja, rígida y potencialmente exponencial en tamaño.

---

## 5.6 Propiedades de Clausura de Lenguajes Regulares

Una de las propiedades más importantes de los Lenguajes Regulares (LR) es su clausura bajo un conjunto de operaciones. Esto significa que si tomamos uno o más lenguajes que sabemos que son regulares, y aplicamos una de estas operaciones (como unión, intersección o concatenación), el lenguaje resultante siempre será también un lenguaje regular.

El Teorema de Kleene establece que un lenguaje es regular si y solo si es aceptado por un Autómata Finito (AF). Por lo tanto, para demostrar que los LRs son cerrados bajo una operación, es suficiente con demostrar que si tenemos los Autómatas Finitos Deterministas (AFDs) para los lenguajes originales, podemos construir un nuevo autómata finito que reconozca el lenguaje resultante.

---

### Clausura bajo Unión e Intersección (Construcción de Producto)

La demostración de clausura para la unión ($L_1 \cup L_2$) y la intersección ($L_1 \cap L_2$) se realiza de manera elegante y simultánea utilizando una técnica llamada Construcción de Producto Cartesiano (o "construcción de parejas").

Supongamos que tenemos dos lenguajes regulares, $L_1$ y $L_2$, aceptados por los AFDs:

* $A_{1}=(Q_{1},\Sigma,\delta_{1},q_{0,1},F_{1})$ para $L_{1}$
* $A_{2}=(Q_{2},\Sigma,\delta_{2},q_{0,2},F_{2})$ para $L_{2}$

Construimos un nuevo AFD, $A_{p}$, que simula la ejecución de $A_{1}$ y $A_{2}$ en paralelo.

1.  **Estados ($Q_{p}$):** El nuevo conjunto de estados es el producto cartesiano de los estados originales: $Q_{p}=Q_{1}\times Q_{2}$. Cada estado en $A_{p}$ es una pareja $[q_{i},q_{j}]$, donde $q_{i}\in Q_{1}$ y $q_{j}\in Q_{2}$.

2.  **Estado Inicial ($q_{0,p}$):** El estado inicial es la pareja de los estados iniciales originales: $q_{0,p}=[q_{0,1},q_{0,2}]$.

3.  **Función de Transición ($\delta_{p}$):** La nueva función de transición simula ambas transiciones a la vez. Para cualquier símbolo $a\in\Sigma$:
    $$
    \delta_{p}([q_{i},q_{j}],a)=[\delta_{1}(q_{i},a),\delta_{2}(q_{j},a)]
    $$

El único componente que difiere entre la unión y la intersección es la definición de los estados finales ($F_{p}$).

1.  **Unión ($L_{1}\cup L_{2}$)**
    Para que una palabra sea aceptada en la unión, debe ser aceptada por $A_{1}$ o por $A_{2}$.
    * **Estados Finales ($F_{\cup}$):** Un estado $[q_{i},q_{j}]$ es final si $q_{i}$ es final en $A_{1}$ o $q_{j}$ es final en $A_{2}$.
        $$
        F_{\cup}=\{[q_{i},q_{j}]\in Q_{p} | q_{i}\in F_{1} \text{ o } q_{j}\in F_{2}\}
        $$

2.  **Intersección ($L_{1}\cap L_{2}$)**
    Para que una palabra sea aceptada en la intersección, debe ser aceptada por $A_{1}$ y por $A_{2}$.
    * **Estados Finales ($F_{\cap}$):** Un estado $[q_{i},q_{j}]$ es final solo si $q_{i}$ es final en $A_{1}$ y $q_{j}$ es final en $A_{2}$.
        $$
        F_{\cap}=\{[q_{i},q_{j}]\in Q_{p} | q_{i}\in F_{1} \text{ y } q_{j}\in F_{2}\}
        $$

Dado que podemos construir algorítmicamente un AFD para ambas operaciones, los lenguajes regulares son cerrados bajo la unión y la intersección.

---

### Clausura bajo Concatenación ($L_{1}\cdot L_{2}$)

Demostrar la clausura bajo concatenación ($L_{1}\cdot L_{2}$) usando exclusivamente AFDs no es directo. La "construcción de producto" no funciona porque un AFD no puede "adivinar" en qué punto de la cadena de entrada termina la parte de $L_{1}$ y comienza la parte de $L_{2}$. Esta "adivinanza" es una característica clave del no determinismo.

La demostración formal de la clausura bajo concatenación se basa en la equivalencia de modelos:

1.  **Construcción vía AFN-$\epsilon$:** Es trivial construir un Autómata Finito No Determinista con transiciones épsilon (AFN-$\epsilon$) que acepte $L_{1}\cdot L_{2}$. Simplemente se toman los autómatas $A_{1}$ y $A_{2}$, y se añaden transiciones-$\epsilon$ desde todos los estados finales de $A_{1}$ al estado inicial de $A_{2}$.

2.  **Equivalencia de Modelos:** Existe un algoritmo formal (la "construcción de subconjuntos" o *powerset construction*) que prueba que para cualquier AFN-$\epsilon$, existe un AFD equivalente que acepta exactamente el mismo lenguaje.

3.  **Conclusión:** Dado que podemos construir un AFN-$\epsilon$ para $L_{1}\cdot L_{2}$ y sabemos que debe existir un AFD equivalente, se demuestra que el lenguaje $L_{1}\cdot L_{2}$ es regular.

Por lo tanto, la familia de lenguajes regulares es cerrada bajo concatenación.